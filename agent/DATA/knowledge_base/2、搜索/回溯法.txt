回溯法（Backtracking）
====================

算法概述
--------
回溯法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），
回溯算法会通过在上一步进行一些变化来丢弃该解，即"回溯"并再次尝试。
回溯法本质上是深度优先搜索（DFS）在组合问题上的应用。

核心思想
--------
1. 系统地搜索解空间
2. 使用递归实现深度优先搜索
3. 在搜索过程中剪枝，避免无效搜索
4. 当发现当前路径不可能得到解时，立即回溯
5. 时间复杂度：取决于解空间大小
6. 空间复杂度：O(d)，d为递归深度

基础模板：回溯法框架
------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

// 回溯法通用模板
void backtrack(状态参数) {
    // 终止条件：找到一个解
    if (满足终止条件) {
        记录或输出解;
        return;
    }

    // 枚举所有可能的选择
    for (int i = 0; i < 选择列表.size(); i++) {
        // 做选择
        标记当前选择;
        更新状态;

        // 递归进入下一层
        backtrack(新状态);

        // 撤销选择（回溯）
        恢复状态;
    }
}
```

Python版本：
```python
def backtrack(状态参数):
    # 终止条件
    if 满足终止条件:
        记录或输出解
        return

    # 枚举所有可能的选择
    for i in range(len(选择列表)):
        # 做选择
        标记当前选择
        更新状态

        # 递归进入下一层
        backtrack(新状态)

        # 撤销选择（回溯）
        恢复状态
```

应用一：排列问题
--------------
生成1到n的所有排列。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<int> path;
bool used[10];

void backtrack() {
    // 终止条件：路径长度为n
    if (path.size() == n) {
        for (int x : path) {
            cout << x << " ";
        }
        cout << '\n';
        return;
    }

    // 枚举1到n
    for (int i = 1; i <= n; i++) {
        if (!used[i]) {
            // 做选择
            used[i] = true;
            path.push_back(i);

            // 递归
            backtrack();

            // 撤销选择
            path.pop_back();
            used[i] = false;
        }
    }
}

int main() {
    cin >> n;
    backtrack();

    return 0;
}
```

Python版本：
```python
def backtrack(n, path, used):
    """生成1到n的所有排列"""
    # 终止条件
    if len(path) == n:
        print(' '.join(map(str, path)))
        return

    # 枚举1到n
    for i in range(1, n + 1):
        if not used[i]:
            # 做选择
            used[i] = True
            path.append(i)

            # 递归
            backtrack(n, path, used)

            # 撤销选择
            path.pop()
            used[i] = False

def main():
    n = int(input())
    backtrack(n, [], [False] * (n + 1))

if __name__ == "__main__":
    main()
```

应用二：组合问题
--------------
从1到n中选取k个数的所有组合。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;
vector<int> path;

void backtrack(int start) {
    // 终止条件：选取了k个数
    if (path.size() == k) {
        for (int x : path) {
            cout << x << " ";
        }
        cout << '\n';
        return;
    }

    // 从start开始枚举
    for (int i = start; i <= n; i++) {
        // 剪枝：剩余元素不足
        if (path.size() + (n - i + 1) < k) {
            break;
        }

        // 做选择
        path.push_back(i);

        // 递归（注意从i+1开始，避免重复）
        backtrack(i + 1);

        // 撤销选择
        path.pop_back();
    }
}

int main() {
    cin >> n >> k;
    backtrack(1);

    return 0;
}
```

Python版本：
```python
def backtrack(n, k, start, path):
    """从1到n中选取k个数的所有组合"""
    # 终止条件
    if len(path) == k:
        print(' '.join(map(str, path)))
        return

    # 从start开始枚举
    for i in range(start, n + 1):
        # 剪枝：剩余元素不足
        if len(path) + (n - i + 1) < k:
            break

        # 做选择
        path.append(i)

        # 递归（注意从i+1开始，避免重复）
        backtrack(n, k, i + 1, path)

        # 撤销选择
        path.pop()

def main():
    n, k = map(int, input().split())
    backtrack(n, k, 1, [])

if __name__ == "__main__":
    main()
```

应用三：N皇后问题
---------------
在n×n的棋盘上放置n个皇后，使得它们不能相互攻击。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int count_queens = 0;

// 检查放置是否合法
bool is_valid(vector<string>& board, int row, int col) {
    // 检查列
    for (int i = 0; i < row; i++) {
        if (board[i][col] == 'Q') {
            return false;
        }
    }

    // 检查左上对角线
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q') {
            return false;
        }
    }

    // 检查右上对角线
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q') {
            return false;
        }
    }

    return true;
}

void backtrack(vector<string>& board, int row) {
    // 终止条件：成功放置所有皇后
    if (row == n) {
        count_queens++;
        for (string& s : board) {
            cout << s << '\n';
        }
        cout << '\n';
        return;
    }

    // 枚举每一列
    for (int col = 0; col < n; col++) {
        if (is_valid(board, row, col)) {
            // 做选择：放置皇后
            board[row][col] = 'Q';

            // 递归到下一行
            backtrack(board, row + 1);

            // 撤销选择：移除皇后
            board[row][col] = '.';
        }
    }
}

int main() {
    cin >> n;

    vector<string> board(n, string(n, '.'));

    backtrack(board, 0);

    cout << "总共有 " << count_queens << " 种解法\n";

    return 0;
}
```

Python版本：
```python
def is_valid(board, row, col, n):
    """检查在(row, col)放置皇后是否合法"""
    # 检查列
    for i in range(row):
        if board[i][col] == 'Q':
            return False

    # 检查左上对角线
    for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
        if board[i][j] == 'Q':
            return False

    # 检查右上对角线
    for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):
        if board[i][j] == 'Q':
            return False

    return True

def backtrack(board, row, n, solutions):
    """N皇后回溯"""
    # 终止条件
    if row == n:
        solutions.append([''.join(row) for row in board])
        return

    # 枚举每一列
    for col in range(n):
        if is_valid(board, row, col, n):
            # 做选择
            board[row][col] = 'Q'

            # 递归
            backtrack(board, row + 1, n, solutions)

            # 撤销选择
            board[row][col] = '.'

def solve_n_queens(n):
    """求解N皇后问题"""
    board = [['.' for _ in range(n)] for _ in range(n)]
    solutions = []
    backtrack(board, 0, n, solutions)

    print(f"总共有 {len(solutions)} 种解法")

    # 输出前几种解法
    for i, solution in enumerate(solutions[:3]):
        print(f"\n解法 {i + 1}:")
        for row in solution:
            print(row)

def main():
    n = int(input())
    solve_n_queens(n)

if __name__ == "__main__":
    main()
```

应用四：解数独
-----------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<vector<char>> board;

bool isValid(int row, int col, char num) {
    // 检查行
    for (int j = 0; j < 9; j++) {
        if (board[row][j] == num) {
            return false;
        }
    }

    // 检查列
    for (int i = 0; i < 9; i++) {
        if (board[i][col] == num) {
            return false;
        }
    }

    // 检查3x3宫格
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[startRow + i][startCol + j] == num) {
                return false;
            }
        }
    }

    return true;
}

bool backtrack() {
    // 找到空格
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                // 尝试填入1-9
                for (char num = '1'; num <= '9'; num++) {
                    if (isValid(i, j, num)) {
                        board[i][j] = num;

                        if (backtrack()) {
                            return true;
                        }

                        board[i][j] = '.';  // 回溯
                    }
                }
                return false;  // 尝试了所有数字都不行
            }
        }
    }
    return true;  // 所有格子都填满了
}

void solveSudoku() {
    backtrack();
}

int main() {
    board.resize(9, vector<char>(9));

    cout << "输入数独（.表示空格）:\n";
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            cin >> board[i][j];
        }
    }

    solveSudoku();

    cout << "\n解:\n";
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            cout << board[i][j] << " ";
        }
        cout << '\n';
    }

    return 0;
}
```

Python版本：
```python
def is_valid(board, row, col, num):
    """检查在(row, col)放置num是否合法"""
    # 检查行
    for j in range(9):
        if board[row][j] == num:
            return False

    # 检查列
    for i in range(9):
        if board[i][col] == num:
            return False

    # 检查3x3宫格
    start_row, start_col = (row // 3) * 3, (col // 3) * 3
    for i in range(3):
        for j in range(3):
            if board[start_row + i][start_col + j] == num:
                return False

    return True

def backtrack(board):
    """数独回溯"""
    # 找到空格
    for i in range(9):
        for j in range(9):
            if board[i][j] == '.':
                # 尝试填入1-9
                for num in '123456789':
                    if is_valid(board, i, j, num):
                        board[i][j] = num

                        if backtrack(board):
                            return True

                        board[i][j] = '.'  # 回溯

                return False  # 尝试了所有数字都不行

    return True  # 所有格子都填满了

def solve_sudoku(board):
    """求解数独"""
    board = [list(row) for row in board]
    backtrack(board)
    return [''.join(row) for row in board]

def main():
    print("输入数独（.表示空格）:")
    board = []
    for _ in range(9):
        row = input().strip()
        board.append(list(row))

    solved = solve_sudoku(board)

    print("\n解:")
    for row in solved:
        print(' '.join(row))

if __name__ == "__main__":
    main()
```

应用五：子集问题
--------------
生成集合的所有子集。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> nums;
vector<int> path;
vector<vector<int>> result;

void backtrack(int start) {
    // 每个节点都是一个子集
    result.push_back(path);

    // 枚举
    for (int i = start; i < nums.size(); i++) {
        // 做选择
        path.push_back(nums[i]);

        // 递归
        backtrack(i + 1);

        // 撤销选择
        path.pop_back();
    }
}

int main() {
    int n;
    cin >> n;

    nums.resize(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    backtrack(0);

    cout << "共有 " << result.size() << " 个子集:\n";
    for (auto& subset : result) {
        for (int x : subset) {
            cout << x << " ";
        }
        cout << '\n';
    }

    return 0;
}
```

Python版本：
```python
def backtrack(nums, start, path, result):
    """生成所有子集"""
    # 每个节点都是一个子集
    result.append(path[:])

    # 枚举
    for i in range(start, len(nums)):
        # 做选择
        path.append(nums[i])

        # 递归
        backtrack(nums, i + 1, path, result)

        # 撤销选择
        path.pop()

def subsets(nums):
    """生成集合的所有子集"""
    result = []
    backtrack(nums, 0, [], result)
    return result

def main():
    nums = list(map(int, input().split()))
    result = subsets(nums)

    print(f"共有 {len(result)} 个子集:")
    for subset in result:
        print(subset)

if __name__ == "__main__":
    main()
```

应用六：分割回文串
---------------
将字符串分割为回文串的所有可能方案。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
vector<string> path;
vector<vector<string>> result;

// 判断是否是回文串
bool isPalindrome(const string& str, int left, int right) {
    while (left < right) {
        if (str[left] != str[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

void backtrack(int start) {
    // 终止条件：分割到字符串末尾
    if (start == s.length()) {
        result.push_back(path);
        return;
    }

    // 枚举所有可能的分割点
    for (int i = start; i < s.length(); i++) {
        // 如果是回文串，则可以分割
        if (isPalindrome(s, start, i)) {
            // 做选择
            path.push_back(s.substr(start, i - start + 1));

            // 递归
            backtrack(i + 1);

            // 撤销选择
            path.pop_back();
        }
    }
}

int main() {
    cin >> s;

    backtrack(0);

    cout << "共有 " << result.size() << " 种分割方案:\n";
    for (auto& partition : result) {
        for (string& str : partition) {
            cout << str << " ";
        }
        cout << '\n';
    }

    return 0;
}
```

Python版本：
```python
def is_palindrome(s, left, right):
    """判断是否是回文串"""
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

def backtrack(s, start, path, result):
    """分割回文串"""
    # 终止条件
    if start == len(s):
        result.append(path[:])
        return

    # 枚举所有可能的分割点
    for i in range(start, len(s)):
        # 如果是回文串，则可以分割
        if is_palindrome(s, start, i):
            # 做选择
            path.append(s[start:i + 1])

            # 递归
            backtrack(s, i + 1, path, result)

            # 撤销选择
            path.pop()

def partition(s):
    """将字符串分割为回文串的所有方案"""
    result = []
    backtrack(s, 0, [], result)
    return result

def main():
    s = input()
    result = partition(s)

    print(f"共有 {len(result)} 种分割方案:")
    for partition in result:
        print(' '.join(partition))

if __name__ == "__main__":
    main()
```

典型例题
--------
1. 全排列（LeetCode46）：生成所有排列
2. 组合（LeetCode77）：从n个数中选k个
3. N皇后（LeetCode51）：经典回溯问题
4. 解数独（LeetCode37）：填充数独
5. 子集（LeetCode78）：生成所有子集
6. 分割回文串（LeetCode131）：字符串分割
7. 电话号码字母组合（LeetCode17）：字母组合
8. 单词搜索（LeetCode79）：网格中搜索单词

注意事项
--------
1. 回溯法的核心：
   - 选择：做出一个选择
   - 约束：检查选择是否合法
   - 目标：判断是否达到目标
   - 回溯：撤销选择

2. 剪枝优化：
   - 提前终止不可能的分支
   - 减少递归调用次数
   - 提高算法效率

3. 实现技巧：
   - 使用路径数组记录当前选择
   - 使用标记数组记录使用情况
   - 注意参数传递和状态恢复

4. 时间复杂度：
   - 排列：O(n!)
   - 组合：O(C(n,k))
   - 取决于解空间大小

5. 空间复杂度：
   - O(n)：递归栈的深度
   - 主要消耗在路径数组上

回溯法 vs 暴力枚举
------------------
| 特性 | 回溯法 | 暴力枚举 |
|------|--------|---------|
| 剪枝 | 有 | 无 |
| 效率 | 较高 | 较低 |
| 实现 | 递归 | 循环 |
| 适用 | 组合问题 | 简单问题 |

回溯法是解决组合问题的强大工具，掌握好回溯法的模板和剪枝技巧，
可以高效地解决各类排列组合、约束满足等问题。
