线性基（Linear Basis）
====================

算法概述
--------
线性基是一种用于处理异或运算的数据结构。
它可以高效地维护一个数集的线性基，支持查询最大异或和、最小异或和、第k小异或和等操作。
时间复杂度通常为O(n log MAXVAL)，其中MAXVAL是数值范围。

基本概念
--------
对于一组数，它们的线性基是这组数的一个极小子集，使得原集合中任意一个数都可以由线性基中的若干个数异或得到。

线性基的性质：
1. 线性基中元素互相异或不能得到0（除非是0本身）
2. 线性基中每个数的二进制最高位互不相同
3. 线性基中元素的个数不超过log(MAXVAL)

基础模板：线性基构建
--------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

struct LinearBasis {
    ll base[65];  // base[i]表示最高位为i的数
    int cnt;      // 线性基大小

    LinearBasis() {
        memset(base, 0, sizeof(base));
        cnt = 0;
    }

    // 插入一个数
    bool insert(ll x) {
        for (int i = 62; i >= 0; i--) {
            if (!(x >> i & 1)) continue;  // 第i位不是1

            if (!base[i]) {
                base[i] = x;
                cnt++;
                return true;
            }

            x ^= base[i];
        }

        return false;  // x可以被异或得到，插入失败
    }

    // 查询x是否可以被表示
    bool check(ll x) {
        for (int i = 62; i >= 0; i--) {
            if (!(x >> i & 1)) continue;
            if (!base[i]) return false;
            x ^= base[i];
        }
        return true;
    }

    // 查询最大异或和
    ll query_max() {
        ll res = 0;
        for (int i = 62; i >= 0; i--) {
            if ((res ^ base[i]) > res) {
                res ^= base[i];
            }
        }
        return res;
    }

    // 查询最小异或和
    ll query_min() {
        for (int i = 0; i <= 62; i++) {
            if (base[i]) return base[i];
        }
        return 0;
    }
};

int main() {
    int n;
    cin >> n;

    LinearBasis lb;

    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x;
        lb.insert(x);
    }

    cout << "最大异或和：" << lb.query_max() << '\n';
    cout << "最小异或和：" << lb.query_min() << '\n';

    return 0;
}
```

Python版本：
```python
from typing import List

class LinearBasis:
    def __init__(self):
        self.base = [0] * 65  # base[i]表示最高位为i的数
        self.cnt = 0  # 线性基大小

    def insert(self, x: int) -> bool:
        """插入一个数"""
        for i in range(62, -1, -1):
            if not (x >> i) & 1:
                continue
            if not self.base[i]:
                self.base[i] = x
                self.cnt += 1
                return True
            x ^= self.base[i]
        return False

    def check(self, x: int) -> bool:
        """查询x是否可以被表示"""
        for i in range(62, -1, -1):
            if not (x >> i) & 1:
                continue
            if not self.base[i]:
                return False
            x ^= self.base[i]
        return True

    def query_max(self) -> int:
        """查询最大异或和"""
        res = 0
        for i in range(62, -1, -1):
            if (res ^ self.base[i]) > res:
                res ^= self.base[i]
        return res

    def query_min(self) -> int:
        """查询最小异或和"""
        for i in range(63):
            if self.base[i]:
                return self.base[i]
        return 0

def solve():
    n = int(input())
    lb = LinearBasis()

    for _ in range(n):
        x = int(input())
        lb.insert(x)

    print(f"最大异或和：{lb.query_max()}")
    print(f"最小异或和：{lb.query_min()}")

solve()
```

应用一：查询第k小异或和
----------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

struct LinearBasis {
    ll base[65];
    ll basis[65];  // 用于查询第k小
    int cnt;

    LinearBasis() {
        memset(base, 0, sizeof(base));
        memset(basis, 0, sizeof(basis));
        cnt = 0;
    }

    bool insert(ll x) {
        for (int i = 62; i >= 0; i--) {
            if (!(x >> i & 1)) continue;
            if (!base[i]) {
                base[i] = x;
                cnt++;
                return true;
            }
            x ^= base[i];
        }
        return false;
    }

    // 预处理，使每位只被更高的位影响
    void rebuild() {
        for (int i = 62; i >= 0; i--) {
            for (int j = i - 1; j >= 0; j--) {
                if (base[i] >> j & 1) {
                    base[i] ^= base[j];
                }
            }
        }

        cnt = 0;
        for (int i = 0; i <= 62; i++) {
            if (base[i]) {
                basis[cnt++] = base[i];
            }
        }
    }

    // 查询第k小（k从1开始）
    ll query_kth(ll k) {
        if (k >= (1LL << cnt)) return -1;  // 超出范围

        ll res = 0;
        for (int i = 62; i >= 0; i--) {
            if (basis[i]) {
                if (k & 1) {
                    res ^= basis[i];
                }
                k >>= 1;
            }
        }
        return res;
    }
};

int main() {
    int n;
    cin >> n;

    LinearBasis lb;

    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x;
        lb.insert(x);
    }

    lb.rebuild();

    int q;
    cin >> q;
    while (q--) {
        ll k;
        cin >> k;
        cout << lb.query_kth(k) << '\n';
    }

    return 0;
}
```

Python版本：
```python
class LinearBasis:
    def __init__(self):
        self.base = [0] * 65
        self.basis = [0] * 65
        self.cnt = 0

    def insert(self, x: int) -> bool:
        for i in range(62, -1, -1):
            if not (x >> i) & 1:
                continue
            if not self.base[i]:
                self.base[i] = x
                self.cnt += 1
                return True
            x ^= self.base[i]
        return False

    def rebuild(self):
        """预处理，使每位只被更高的位影响"""
        for i in range(62, -1, -1):
            for j in range(i - 1, -1, -1):
                if (self.base[i] >> j) & 1:
                    self.base[i] ^= self.base[j]

        self.cnt = 0
        for i in range(63):
            if self.base[i]:
                self.basis[self.cnt] = self.base[i]
                self.cnt += 1

    def query_kth(self, k: int) -> int:
        """查询第k小（k从1开始）"""
        if k >= (1 << self.cnt):
            return -1

        res = 0
        for i in range(62, -1, -1):
            if self.basis[i]:
                if k & 1:
                    res ^= self.basis[i]
                k >>= 1
        return res

def solve():
    n = int(input())
    lb = LinearBasis()

    for _ in range(n):
        x = int(input())
        lb.insert(x)

    lb.rebuild()

    q = int(input())
    for _ in range(q):
        k = int(input())
        print(lb.query_kth(k))

solve()
```

应用二：区间线性基
----------------
使用线段树维护区间线性基。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

struct LinearBasis {
    ll base[65];

    LinearBasis() {
        memset(base, 0, sizeof(base));
    }

    // 合并两个线性基
    void merge(const LinearBasis& other) {
        for (int i = 62; i >= 0; i--) {
            if (other.base[i]) {
                insert(other.base[i]);
            }
        }
    }

    void insert(ll x) {
        for (int i = 62; i >= 0; i--) {
            if (!(x >> i & 1)) continue;
            if (!base[i]) {
                base[i] = x;
                return;
            }
            x ^= base[i];
        }
    }

    ll query_max() {
        ll res = 0;
        for (int i = 62; i >= 0; i--) {
            if ((res ^ base[i]) > res) {
                res ^= base[i];
            }
        }
        return res;
    }
};

const int MAXN = 100005;
LinearBasis tree[MAXN * 4];
ll a[MAXN];

// 建树
void build(int node, int l, int r) {
    if (l == r) {
        tree[node].insert(a[l]);
        return;
    }
    int mid = (l + r) / 2;
    build(node * 2, l, mid);
    build(node * 2 + 1, mid + 1, r);
    tree[node] = tree[node * 2];
    tree[node].merge(tree[node * 2 + 1]);
}

// 查询区间[l, r]的线性基
LinearBasis query(int node, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) {
        return tree[node];
    }
    int mid = (l + r) / 2;
    LinearBasis res;
    if (ql <= mid) {
        res.merge(query(node * 2, l, mid, ql, qr));
    }
    if (qr > mid) {
        res.merge(query(node * 2 + 1, mid + 1, r, ql, qr));
    }
    return res;
}

int main() {
    int n, q;
    cin >> n >> q;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    build(1, 1, n);

    while (q--) {
        int l, r;
        cin >> l >> r;
        LinearBasis lb = query(1, 1, n, l, r);
        cout << lb.query_max() << '\n';
    }

    return 0;
}
```

Python版本：
```python
class LinearBasis:
    def __init__(self):
        self.base = [0] * 65

    def merge(self, other):
        """合并两个线性基"""
        for i in range(62, -1, -1):
            if other.base[i]:
                self.insert(other.base[i])

    def insert(self, x):
        for i in range(62, -1, -1):
            if not (x >> i) & 1:
                continue
            if not self.base[i]:
                self.base[i] = x
                return
            x ^= self.base[i]

    def query_max(self):
        res = 0
        for i in range(62, -1, -1):
            if (res ^ self.base[i]) > res:
                res ^= self.base[i]
        return res

class SegmentTree:
    def __init__(self, n, a):
        self.n = n
        self.a = a
        self.tree = [LinearBasis() for _ in range(4 * n)]
        self.build(1, 1, n)

    def build(self, node, l, r):
        if l == r:
            self.tree[node].insert(self.a[l])
            return
        mid = (l + r) // 2
        self.build(node * 2, l, mid)
        self.build(node * 2 + 1, mid + 1, r)
        self.tree[node] = self.tree[node * 2]
        self.tree[node].merge(self.tree[node * 2 + 1])

    def query(self, node, l, r, ql, qr):
        if ql <= l and r <= qr:
            return self.tree[node]
        mid = (l + r) // 2
        res = LinearBasis()
        if ql <= mid:
            res.merge(self.query(node * 2, l, mid, ql, qr))
        if qr > mid:
            res.merge(self.query(node * 2 + 1, mid + 1, r, ql, qr))
        return res

def solve():
    n, q = map(int, input().split())
    a = [0] + [int(input()) for _ in range(n)]

    seg = SegmentTree(n, a)

    for _ in range(q):
        l, r = map(int, input().split())
        lb = seg.query(1, 1, n, l, r)
        print(lb.query_max())

solve()
```

应用三：异或最大值对
------------------
给定n个数，求两数异或的最大值。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

struct LinearBasis {
    ll base[65];

    LinearBasis() {
        memset(base, 0, sizeof(base));
    }

    void insert(ll x) {
        for (int i = 62; i >= 0; i--) {
            if (!(x >> i & 1)) continue;
            if (!base[i]) {
                base[i] = x;
                return;
            }
            x ^= base[i];
        }
    }

    ll query_max(ll x) {
        for (int i = 62; i >= 0; i--) {
            if ((x ^ base[i]) > x) {
                x ^= base[i];
            }
        }
        return x;
    }
};

int main() {
    int n;
    cin >> n;

    vector<ll> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    LinearBasis lb;
    ll ans = 0;

    for (int i = 0; i < n; i++) {
        lb.insert(a[i]);
        ans = max(ans, lb.query_max(a[i]));
    }

    cout << ans << '\n';

    return 0;
}
```

典型例题
--------
1. 【模板】线性基（洛谷P3812）：基本操作
2. 异或之迷（洛谷P3857）：区间查询
3. 最大异或和（洛谷P4570）：第k小异或和
4. Xor-matrix（Codeforces 959E）：矩阵异或

注意事项
--------
1. 数据范围：
   - 线性基大小不超过log(MAXVAL)
   - 对于long long，最多63个元素

2. 优化技巧：
   - 高斯消元法构造线性基
   - 预处理使线性基成为上三角形式

3. 边界情况：
   - 所有数都为0
   - 重复的数

4. 常见错误：
   - 忘记处理x=0的情况
   - 查询第k小时k的范围判断错误

时间复杂度总结
--------------
- 插入：O(log MAXVAL)
- 查询最大/最小：O(log MAXVAL)
- 查询第k小：O(log² MAXVAL)
- 空间复杂度：O(log MAXVAL)

线性基是处理异或问题的强大工具，
掌握它对解决异或相关问题有很大帮助。
