康托展开与逆康托展开
==================

算法概述
--------
康托展开是一个全排列到一个自然数的双射，常用于构建哈希表。
它可以将一个排列映射为唯一的整数，也可以从整数逆推出排列。
在状态压缩、哈希表、搜索算法中有广泛应用。

康托展开
--------
对于一个排列 {a1, a2, ..., an}，其康托展开值为：
    X = a1 × (n-1)! + a2 × (n-2)! + ... + an-1 × 1! + an × 0!

其中 ai 表示在当前未使用的元素中，ai 是第几小的（从0开始计数）。

公式：
    X = Σ(ai × (n-i-1)!)，i从1到n

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 20;
ll fact[MAXN];  // 阶乘

// 预处理阶乘
void init_factorial(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = fact[i-1] * i;
    }
}

// 康托展开
ll cantor_expand(const vector<int>& perm, int n) {
    ll result = 0;
    vector<bool> used(n + 1, false);

    for (int i = 0; i < n; i++) {
        int x = perm[i];
        int smaller = 0;  // 在x之前且比x小的未使用元素个数
        for (int j = 1; j < x; j++) {
            if (!used[j]) {
                smaller++;
            }
        }
        result += smaller * fact[n - i - 1];
        used[x] = true;
    }

    return result + 1;  // 从1开始编号
}

// 优化版本：使用树状数组
ll cantor_expand_optimized(const vector<int>& perm, int n) {
    ll result = 0;
    vector<int> bit(n + 2, 0);

    auto update = [&](int i, int delta) {
        for (; i <= n; i += i & (-i)) {
            bit[i] += delta;
        }
    };

    auto query = [&](int i) {
        int sum = 0;
        for (; i > 0; i -= i & (-i)) {
            sum += bit[i];
        }
        return sum;
    };

    for (int i = 1; i <= n; i++) {
        update(i, 1);
    }

    for (int i = 0; i < n; i++) {
        int x = perm[i];
        int smaller = query(x - 1);  // 比x小的未使用元素个数
        result += smaller * fact[n - i - 1];
        update(x, -1);
    }

    return result + 1;
}

int main() {
    int n;
    cin >> n;

    init_factorial(n);

    vector<int> perm(n);
    for (int i = 0; i < n; i++) {
        cin >> perm[i];
    }

    ll result = cantor_expand_optimized(perm, n);
    cout << "康托展开值：" << result << '\n';

    return 0;
}
```

Python版本：
```python
from typing import List

def init_factorial(n: int):
    """预处理阶乘"""
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i
    return fact

def cantor_expand(perm: List[int], n: int, fact: List[int]) -> int:
    """康托展开"""
    result = 0
    used = [False] * (n + 1)

    for i in range(n):
        x = perm[i]
        # 计算在x之前且比x小的未使用元素个数
        smaller = sum(1 for j in range(1, x) if not used[j])
        result += smaller * fact[n - i - 1]
        used[x] = True

    return result + 1  # 从1开始编号

def cantor_expand_optimized(perm: List[int], n: int, fact: List[int]) -> int:
    """优化版本：使用树状数组"""
    class BIT:
        def __init__(self, n):
            self.n = n
            self.bit = [0] * (n + 2)

        def update(self, i: int, delta: int):
            while i <= self.n:
                self.bit[i] += delta
                i += i & (-i)

        def query(self, i: int) -> int:
            s = 0
            while i > 0:
                s += self.bit[i]
                i -= i & (-i)
            return s

    result = 0
    bit = BIT(n)

    for i in range(1, n + 1):
        bit.update(i, 1)

    for i in range(n):
        x = perm[i]
        smaller = bit.query(x - 1)
        result += smaller * fact[n - i - 1]
        bit.update(x, -1)

    return result + 1

def solve():
    n = int(input())
    perm = list(map(int, input().split()))
    fact = init_factorial(n)
    result = cantor_expand_optimized(perm, n, fact)
    print(f"康托展开值：{result}")

solve()
```

逆康托展开
----------
从康托展开值逆推出原始排列。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 20;
ll fact[MAXN];

// 预处理阶乘
void init_factorial(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = fact[i-1] * i;
    }
}

// 逆康托展开
vector<int> inverse_cantor(ll x, int n) {
    x--;  // 转为从0开始

    vector<int> perm(n);
    vector<bool> used(n + 1, false);

    for (int i = 0; i < n; i++) {
        ll idx = x / fact[n - i - 1];  // 当前位是第几小的
        x %= fact[n - i - 1];

        // 找到第idx小的未使用元素
        int cnt = 0;
        for (int j = 1; j <= n; j++) {
            if (!used[j]) {
                if (cnt == idx) {
                    perm[i] = j;
                    used[j] = true;
                    break;
                }
                cnt++;
            }
        }
    }

    return perm;
}

int main() {
    int n;
    ll x;
    cin >> n >> x;

    init_factorial(n);

    vector<int> perm = inverse_cantor(x, n);
    for (int i = 0; i < n; i++) {
        cout << perm[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本：
```python
from typing import List

def init_factorial(n: int):
    """预处理阶乘"""
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i
    return fact

def inverse_cantor(x: int, n: int, fact: List[int]) -> List[int]:
    """逆康托展开"""
    x -= 1  # 转为从0开始

    perm = [0] * n
    used = [False] * (n + 1)

    for i in range(n):
        idx = x // fact[n - i - 1]
        x %= fact[n - i - 1]

        # 找到第idx小的未使用元素
        cnt = 0
        for j in range(1, n + 1):
            if not used[j]:
                if cnt == idx:
                    perm[i] = j
                    used[j] = True
                    break
                cnt += 1

    return perm

def solve():
    n, x = map(int, input().split())
    fact = init_factorial(n)
    perm = inverse_cantor(x, n, fact)
    print(' '.join(map(str, perm)))

solve()
```

应用一：全排列枚举
------------------
利用康托展开可以高效地枚举所有排列。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 20;
ll fact[MAXN];

void init_factorial(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = fact[i-1] * i;
    }
}

vector<int> inverse_cantor(ll x, int n) {
    x--;
    vector<int> perm(n);
    vector<bool> used(n + 1, false);

    for (int i = 0; i < n; i++) {
        ll idx = x / fact[n - i - 1];
        x %= fact[n - i - 1];

        int cnt = 0;
        for (int j = 1; j <= n; j++) {
            if (!used[j]) {
                if (cnt == idx) {
                    perm[i] = j;
                    used[j] = true;
                    break;
                }
                cnt++;
            }
        }
    }

    return perm;
}

int main() {
    int n;
    cin >> n;

    init_factorial(n);

    // 枚举所有排列
    for (ll i = 1; i <= fact[n]; i++) {
        vector<int> perm = inverse_cantor(i, n);
        for (int j = 0; j < n; j++) {
            cout << perm[j] << " \n"[j == n - 1];
        }
    }

    return 0;
}
```

Python版本：
```python
from typing import List

def init_factorial(n: int):
    """预处理阶乘"""
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i
    return fact

def inverse_cantor(x: int, n: int, fact: List[int]) -> List[int]:
    """逆康托展开"""
    x -= 1
    perm = [0] * n
    used = [False] * (n + 1)

    for i in range(n):
        idx = x // fact[n - i - 1]
        x %= fact[n - i - 1]

        cnt = 0
        for j in range(1, n + 1):
            if not used[j]:
                if cnt == idx:
                    perm[i] = j
                    used[j] = True
                    break
                cnt += 1

    return perm

def solve():
    n = int(input())
    fact = init_factorial(n)

    for i in range(1, fact[n] + 1):
        perm = inverse_cantor(i, n, fact)
        print(' '.join(map(str, perm)))

solve()
```

应用二：排列的排名
------------------
给定一个排列，求它在所有排列中的排名（从1开始）。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 20;
ll fact[MAXN];

void init_factorial(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = fact[i-1] * i;
    }
}

ll cantor_expand(const vector<int>& perm, int n) {
    ll result = 0;
    vector<bool> used(n + 1, false);

    for (int i = 0; i < n; i++) {
        int x = perm[i];
        int smaller = 0;
        for (int j = 1; j < x; j++) {
            if (!used[j]) {
                smaller++;
            }
        }
        result += smaller * fact[n - i - 1];
        used[x] = true;
    }

    return result + 1;
}

int main() {
    int n;
    cin >> n;

    init_factorial(n);

    vector<int> perm(n);
    for (int i = 0; i < n; i++) {
        cin >> perm[i];
    }

    ll rank = cantor_expand(perm, n);
    cout << "排列的排名：" << rank << '\n';

    return 0;
}
```

Python版本：
```python
from typing import List

def init_factorial(n: int):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i
    return fact

def cantor_expand(perm: List[int], n: int, fact: List[int]) -> int:
    result = 0
    used = [False] * (n + 1)

    for i in range(n):
        x = perm[i]
        smaller = sum(1 for j in range(1, x) if not used[j])
        result += smaller * fact[n - i - 1]
        used[x] = True

    return result + 1

def solve():
    n = int(input())
    perm = list(map(int, input().split()))
    fact = init_factorial(n)
    rank = cantor_expand(perm, n, fact)
    print(f"排列的排名：{rank}")

solve()
```

应用三：第k个排列
----------------
给定n和k，求n个元素全排列中字典序第k小的排列。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 20;
ll fact[MAXN];

void init_factorial(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = fact[i-1] * i;
    }
}

vector<int> get_kth_permutation(int n, ll k) {
    vector<int> elements;
    for (int i = 1; i <= n; i++) {
        elements.push_back(i);
    }

    vector<int> result;
    k--;  // 转为从0开始

    for (int i = n; i >= 1; i--) {
        ll idx = k / fact[i - 1];
        k %= fact[i - 1];

        result.push_back(elements[idx]);
        elements.erase(elements.begin() + idx);
    }

    return result;
}

int main() {
    int n;
    ll k;
    cin >> n >> k;

    init_factorial(n);

    vector<int> perm = get_kth_permutation(n, k);
    for (int i = 0; i < n; i++) {
        cout << perm[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本：
```python
from typing import List

def init_factorial(n: int):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i
    return fact

def get_kth_permutation(n: int, k: int, fact: List[int]) -> List[int]:
    elements = list(range(1, n + 1))
    result = []
    k -= 1  # 转为从0开始

    for i in range(n, 0, -1):
        idx = k // fact[i - 1]
        k %= fact[i - 1]

        result.append(elements.pop(idx))

    return result

def solve():
    n, k = map(int, input().split())
    fact = init_factorial(n)
    perm = get_kth_permutation(n, k, fact)
    print(' '.join(map(str, perm)))

solve()
```

典型例题
--------
1. 【模板】康托展开（洛谷P5367）：求排列的排名
2. 【模板】逆康托展开（洛谷P5367）：求第k个排列
3. 全排列问题（LeetCode 60）：第k个排列
4. 火星人（洛谷P3014）：排列的下一个

注意事项
--------
1. 数据范围：
   - n <= 20时，结果在long long范围内
   - n > 20时，结果可能溢出，需要大整数

2. 优化技巧：
   - 使用树状数组优化"比x小的未使用元素个数"的查询
   - 预处理阶乘，避免重复计算

3. 边界情况：
   - k从1开始还是从0开始要搞清楚
   - 排列是否从1开始

4. 常见错误：
   - 阶乘计算溢出
   - 忘记对k进行减1操作
   - 混淆从0开始和从1开始的编号

5. 应用场景：
   - 搜索算法的状态压缩
   - 哈希表的键值构建
   - 排列的枚举和查询

时间复杂度总结
--------------
- 康托展开：O(n²)，使用树状数组可优化到O(n log n)
- 逆康托展开：O(n²)
- 预处理阶乘：O(n)
- 空间复杂度：O(n)

康托展开是排列与自然数之间的桥梁，
它在搜索算法、状态压缩、哈希表等领域都有重要应用。
