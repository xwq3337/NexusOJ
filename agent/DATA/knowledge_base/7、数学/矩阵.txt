矩阵运算与矩阵快速幂
==================

算法概述
--------
矩阵是线性代数的基础，矩阵快速幂是高效计算矩阵n次幂的算法。
它在求解递推关系、线性方程组、图论问题等方面有广泛应用。

矩阵定义与基本运算
------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9 + 7;

struct Matrix {
    int n, m;
    vector<vector<ll>> mat;

    Matrix(int n, int m) : n(n), m(m) {
        mat.assign(n, vector<ll>(m, 0));
    }

    // 矩阵乘法
    Matrix operator*(const Matrix& other) const {
        assert(m == other.n);
        Matrix res(n, other.m);
        for (int i = 0; i < n; i++) {
            for (int k = 0; k < m; k++) {
                if (mat[i][k] == 0) continue;
                for (int j = 0; j < other.m; j++) {
                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * other.mat[k][j]) % mod;
                }
            }
        }
        return res;
    }

    // 矩阵加法
    Matrix operator+(const Matrix& other) const {
        assert(n == other.n && m == other.m);
        Matrix res(n, m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                res.mat[i][j] = (mat[i][j] + other.mat[i][j]) % mod;
            }
        }
        return res;
    }

    // 输出矩阵
    void print() const {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << mat[i][j] << " \n"[j == m - 1];
            }
        }
    }
};

// 单位矩阵
Matrix identity(int n) {
    Matrix res(n, n);
    for (int i = 0; i < n; i++) {
        res.mat[i][i] = 1;
    }
    return res;
}

int main() {
    int n, m;
    cin >> n >> m;

    Matrix A(n, m), B(m, n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> A.mat[i][j];
        }
    }
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cin >> B.mat[i][j];
        }
    }

    Matrix C = A * B;
    C.print();

    return 0;
}
```

Python版本：
```python
from typing import List

MOD = 10**9 + 7

class Matrix:
    def __init__(self, n: int, m: int):
        self.n = n
        self.m = m
        self.mat = [[0] * m for _ in range(n)]

    def __mul__(self, other):
        assert self.m == other.n
        res = Matrix(self.n, other.m)
        for i in range(self.n):
            for k in range(self.m):
                if self.mat[i][k] == 0:
                    continue
                for j in range(other.m):
                    res.mat[i][j] = (res.mat[i][j] +
                                    self.mat[i][k] * other.mat[k][j]) % MOD
        return res

    def __add__(self, other):
        assert self.n == other.n and self.m == other.m
        res = Matrix(self.n, self.m)
        for i in range(self.n):
            for j in range(self.m):
                res.mat[i][j] = (self.mat[i][j] + other.mat[i][j]) % MOD
        return res

    def print(self):
        for i in range(self.n):
            print(' '.join(map(str, self.mat[i])))

def identity(n: int) -> Matrix:
    """单位矩阵"""
    res = Matrix(n, n)
    for i in range(n):
        res.mat[i][i] = 1
    return res

def solve():
    n, m = map(int, input().split())
    A = Matrix(n, m)
    B = Matrix(m, n)

    for i in range(n):
        A.mat[i] = list(map(int, input().split()))
    for i in range(m):
        B.mat[i] = list(map(int, input().split()))

    C = A * B
    C.print()

solve()
```

矩阵快速幂
----------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9 + 7;

struct Matrix {
    int n;
    vector<vector<ll>> mat;

    Matrix(int n) : n(n) {
        mat.assign(n, vector<ll>(n, 0));
    }

    Matrix operator*(const Matrix& other) const {
        Matrix res(n);
        for (int i = 0; i < n; i++) {
            for (int k = 0; k < n; k++) {
                if (mat[i][k] == 0) continue;
                for (int j = 0; j < n; j++) {
                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * other.mat[k][j]) % mod;
                }
            }
        }
        return res;
    }

    ll* operator[](int i) {
        return mat[i].data();
    }
};

Matrix identity(int n) {
    Matrix res(n);
    for (int i = 0; i < n; i++) {
        res.mat[i][i] = 1;
    }
    return res;
}

// 矩阵快速幂
Matrix matrix_pow(Matrix a, ll b) {
    int n = a.n;
    Matrix res = identity(n);
    while (b > 0) {
        if (b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

int main() {
    int n;
    ll k;
    cin >> n >> k;

    Matrix a(n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> a.mat[i][j];
        }
    }

    Matrix ans = matrix_pow(a, k);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << ans.mat[i][j] << " \n"[j == n - 1];
        }
    }

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

class Matrix:
    def __init__(self, n: int):
        self.n = n
        self.mat = [[0] * n for _ in range(n)]

    def __mul__(self, other):
        res = Matrix(self.n)
        for i in range(self.n):
            for k in range(self.n):
                if self.mat[i][k] == 0:
                    continue
                for j in range(self.n):
                    res.mat[i][j] = (res.mat[i][j] +
                                    self.mat[i][k] * other.mat[k][j]) % MOD
        return res

def identity(n: int) -> Matrix:
    """单位矩阵"""
    res = Matrix(n)
    for i in range(n):
        res.mat[i][i] = 1
    return res

def matrix_pow(a: Matrix, b: int) -> Matrix:
    """矩阵快速幂"""
    n = a.n
    res = identity(n)
    while b > 0:
        if b & 1:
            res = res * a
        a = a * a
        b >>= 1
    return res

def solve():
    n, k = map(int, input().split())
    a = Matrix(n)
    for i in range(n):
        a.mat[i] = list(map(int, input().split()))

    ans = matrix_pow(a, k)
    for i in range(n):
        print(' '.join(map(str, ans.mat[i])))

solve()
```

应用一：斐波那契数列
--------------------
使用矩阵快速幂求解斐波那契数列第n项。

递推关系：
|F(n)  |   |1 1|   |F(n-1)|
|F(n-1)| = |1 0| × |F(n-2)|

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9 + 7;

struct Matrix {
    ll mat[2][2];

    Matrix() {
        memset(mat, 0, sizeof(mat));
    }

    Matrix operator*(const Matrix& other) const {
        Matrix res;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * other.mat[k][j]) % mod;
                }
            }
        }
        return res;
    }
};

Matrix matrix_pow(Matrix a, ll b) {
    Matrix res;
    res.mat[0][0] = res.mat[1][1] = 1;
    while (b > 0) {
        if (b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

ll fibonacci(ll n) {
    if (n <= 2) return 1;
    Matrix base;
    base.mat[0][0] = base.mat[0][1] = base.mat[1][0] = 1;
    Matrix res = matrix_pow(base, n - 2);
    return (res.mat[0][0] + res.mat[0][1]) % mod;
}

int main() {
    ll n;
    cin >> n;
    cout << fibonacci(n) << '\n';
    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

class Matrix:
    def __init__(self):
        self.mat = [[0, 0], [0, 0]]

    def __mul__(self, other):
        res = Matrix()
        for i in range(2):
            for j in range(2):
                for k in range(2):
                    res.mat[i][j] = (res.mat[i][j] +
                                    self.mat[i][k] * other.mat[k][j]) % MOD
        return res

def matrix_pow(a: Matrix, b: int) -> Matrix:
    res = Matrix()
    res.mat[0][0] = res.mat[1][1] = 1
    while b > 0:
        if b & 1:
            res = res * a
        a = a * a
        b >>= 1
    return res

def fibonacci(n: int) -> int:
    if n <= 2:
        return 1
    base = Matrix()
    base.mat[0][0] = base.mat[0][1] = base.mat[1][0] = 1
    res = matrix_pow(base, n - 2)
    return (res.mat[0][0] + res.mat[0][1]) % MOD

def solve():
    n = int(input())
    print(fibonacci(n))

solve()
```

应用二：求解线性递推
------------------
对于线性递推关系：
f(n) = c1×f(n-1) + c2×f(n-2) + ... + ck×f(n-k)

可以用矩阵快速幂在O(k³log n)时间内求解。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9 + 7;

const int MAXK = 15;

struct Matrix {
    int n;
    ll mat[MAXK][MAXK];

    Matrix(int n) : n(n) {
        memset(mat, 0, sizeof(mat));
    }

    Matrix operator*(const Matrix& other) const {
        Matrix res(n);
        for (int i = 0; i < n; i++) {
            for (int k = 0; k < n; k++) {
                if (mat[i][k] == 0) continue;
                for (int j = 0; j < n; j++) {
                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * other.mat[k][j]) % mod;
                }
            }
        }
        return res;
    }
};

Matrix matrix_pow(Matrix a, ll b) {
    int n = a.n;
    Matrix res(n);
    for (int i = 0; i < n; i++) {
        res.mat[i][i] = 1;
    }
    while (b > 0) {
        if (b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

int main() {
    int k;
    ll n;
    cin >> k >> n;

    ll coeff[MAXK], init[MAXK];
    for (int i = 0; i < k; i++) {
        cin >> coeff[i];  // 系数
    }
    for (int i = 0; i < k; i++) {
        cin >> init[i];  // 初始值
    }

    if (n <= k) {
        cout << init[n - 1] << '\n';
        return 0;
    }

    Matrix trans(k);
    for (int i = 0; i < k; i++) {
        trans.mat[0][i] = coeff[i];
    }
    for (int i = 1; i < k; i++) {
        trans.mat[i][i - 1] = 1;
    }

    Matrix res = matrix_pow(trans, n - k);

    ll ans = 0;
    for (int i = 0; i < k; i++) {
        ans = (ans + res.mat[0][i] * init[k - 1 - i]) % mod;
    }
    cout << ans << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

class Matrix:
    def __init__(self, n: int):
        self.n = n
        self.mat = [[0] * n for _ in range(n)]

    def __mul__(self, other):
        res = Matrix(self.n)
        for i in range(self.n):
            for k in range(self.n):
                if self.mat[i][k] == 0:
                    continue
                for j in range(self.n):
                    res.mat[i][j] = (res.mat[i][j] +
                                    self.mat[i][k] * other.mat[k][j]) % MOD
        return res

def matrix_pow(a: Matrix, b: int) -> Matrix:
    n = a.n
    res = Matrix(n)
    for i in range(n):
        res.mat[i][i] = 1
    while b > 0:
        if b & 1:
            res = res * a
        a = a * a
        b >>= 1
    return res

def solve():
    k, n = map(int, input().split())
    coeff = list(map(int, input().split()))
    init = list(map(int, input().split()))

    if n <= k:
        print(init[n - 1])
        return

    trans = Matrix(k)
    for i in range(k):
        trans.mat[0][i] = coeff[i]
    for i in range(1, k):
        trans.mat[i][i - 1] = 1

    res = matrix_pow(trans, n - k)

    ans = 0
    for i in range(k):
        ans = (ans + res.mat[0][i] * init[k - 1 - i]) % MOD
    print(ans)

solve()
```

应用三：图的路径计数
------------------
给定一个有向图，求从点i到点j长度为k的路径数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9 + 7;

const int MAXN = 105;

struct Matrix {
    int n;
    ll mat[MAXN][MAXN];

    Matrix(int n) : n(n) {
        memset(mat, 0, sizeof(mat));
    }

    Matrix operator*(const Matrix& other) const {
        Matrix res(n);
        for (int i = 0; i < n; i++) {
            for (int k = 0; k < n; k++) {
                if (mat[i][k] == 0) continue;
                for (int j = 0; j < n; j++) {
                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * other.mat[k][j]) % mod;
                }
            }
        }
        return res;
    }
};

Matrix matrix_pow(Matrix a, ll b) {
    int n = a.n;
    Matrix res(n);
    for (int i = 0; i < n; i++) {
        res.mat[i][i] = 1;
    }
    while (b > 0) {
        if (b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

int main() {
    int n, m;
    ll k;
    cin >> n >> m >> k;

    Matrix adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        adj.mat[u][v]++;
    }

    Matrix res = matrix_pow(adj, k);

    int q;
    cin >> q;
    while (q--) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        cout << res.mat[u][v] << '\n';
    }

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

class Matrix:
    def __init__(self, n: int):
        self.n = n
        self.mat = [[0] * n for _ in range(n)]

    def __mul__(self, other):
        res = Matrix(self.n)
        for i in range(self.n):
            for k in range(self.n):
                if self.mat[i][k] == 0:
                    continue
                for j in range(self.n):
                    res.mat[i][j] = (res.mat[i][j] +
                                    self.mat[i][k] * other.mat[k][j]) % MOD
        return res

def matrix_pow(a: Matrix, b: int) -> Matrix:
    n = a.n
    res = Matrix(n)
    for i in range(n):
        res.mat[i][i] = 1
    while b > 0:
        if b & 1:
            res = res * a
        a = a * a
        b >>= 1
    return res

def solve():
    n, m, k = map(int, input().split())
    adj = Matrix(n)

    for _ in range(m):
        u, v = map(int, input().split())
        u -= 1; v -= 1
        adj.mat[u][v] += 1

    res = matrix_pow(adj, k)

    q = int(input())
    for _ in range(q):
        u, v = map(int, input().split())
        u -= 1; v -= 1
        print(res.mat[u][v])

solve()
```

典型例题
--------
1. 【模板】矩阵快速幂（洛谷P3390）：计算矩阵的n次幂
2. 斐波那契数列（洛谷P1962）：第n项
3. 【模板】矩阵加速（递推）：求解线性递推
4. 飞越侠影（洛谷P1939）：三阶斐波那契
5. 逛公园（洛谷P3933）：路径计数

注意事项
--------
1. 时间复杂度：
   - 矩阵乘法：O(n³)
   - 矩阵快速幂：O(n³log k)

2. 优化技巧：
   - 矩阵乘法时跳过0元素
   - 使用long long防止溢出
   - 每次乘法后取模

3. 边界情况：
   - k = 0时返回单位矩阵
   - k = 1时返回原矩阵

4. 常见错误：
   - 忘记取模导致溢出
   - 矩阵乘法顺序错误
   - 初始矩阵构造错误

时间复杂度总结
--------------
- 矩阵乘法：O(n³)
- 矩阵快速幂：O(n³log k)
- 空间复杂度：O(n²)

矩阵快速幂是求解递推关系、路径计数等问题的强大工具，
掌握它对解决很多算法竞赛题目都有帮助。
