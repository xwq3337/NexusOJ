队列（Queue）
====================

算法概述
--------
队列是一种线性数据结构，遵循先进先出(First In First Out, FIFO)的原则。队列只允许在表尾(队尾)进行插入操作，在表头(队头)进行删除操作。

核心特点：
1. 在队尾插入元素，在队头删除元素
2. 先进先出(FIFO)
3. 支持的基本操作：push(入队)、pop(出队)、front(查看队头)、back(查看队尾)、empty(判空)

核心思想
--------
1. 队列可以用数组或链表实现
2. 数组实现：循环队列，维护队头和队尾指针
3. 链表实现：以表头为队头，表尾为队尾
4. 时间复杂度：所有操作均为O(1)

基础模板：队列的基本操作
----------------------

C++版本（循环队列实现）：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

class Queue {
private:
    int data[MAXN];  // 存储队列元素
    int front_idx;   // 队头指针
    int rear_idx;    // 队尾指针
    int size;        // 队列大小

public:
    Queue() : front_idx(0), rear_idx(0), size(0) {}

    // 入队
    void push(int x) {
        data[rear_idx] = x;
        rear_idx = (rear_idx + 1) % MAXN;
        size++;
    }

    // 出队
    void pop() {
        if (size > 0) {
            front_idx = (front_idx + 1) % MAXN;
            size--;
        }
    }

    // 获取队头元素
    int front() {
        return data[front_idx];
    }

    // 获取队尾元素
    int back() {
        return data[(rear_idx - 1 + MAXN) % MAXN];
    }

    // 判断队列是否为空
    bool empty() {
        return size == 0;
    }

    // 获取队列大小
    int get_size() {
        return size;
    }
};

int main() {
    Queue q;

    // 基本操作演示
    q.push(1);
    q.push(2);
    q.push(3);

    cout << "队头元素: " << q.front() << endl;  // 1
    cout << "队尾元素: " << q.back() << endl;   // 3
    cout << "队列大小: " << q.get_size() << endl; // 3

    q.pop();
    cout << "出队后队头: " << q.front() << endl; // 2

    return 0;
}
```

Python版本：
```python
class Queue:
    def __init__(self):
        self.data = []

    def push(self, x):
        """入队"""
        self.data.append(x)

    def pop(self):
        """出队"""
        if not self.empty():
            return self.data.pop(0)

    def front(self):
        """获取队头元素"""
        if not self.empty():
            return self.data[0]

    def back(self):
        """获取队尾元素"""
        if not self.empty():
            return self.data[-1]

    def empty(self):
        """判断队列是否为空"""
        return len(self.data) == 0

    def size(self):
        """获取队列大小"""
        return len(self.data)

# 基本操作演示
q = Queue()
q.push(1)
q.push(2)
q.push(3)

print(f"队头元素: {q.front()}")  # 1
print(f"队尾元素: {q.back()}")   # 3
print(f"队列大小: {q.size()}")   # 3

q.pop()
print(f"出队后队头: {q.front()}") # 2
```

应用一：BFS广度优先搜索
----------------------
队列最经典的应用是实现BFS算法。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;

int n, m;
int grid[MAXN][MAXN];
bool visited[MAXN][MAXN];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

void bfs(int sx, int sy) {
    queue<pair<int, int>> q;
    q.push({sx, sy});
    visited[sx][sy] = true;

    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();

        cout << "访问: " << x << " " << y << endl;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m &&
                !visited[nx][ny] && grid[nx][ny] == 0) {
                visited[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
}

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> grid[i][j];
        }
    }

    int sx, sy;
    cin >> sx >> sy;

    bfs(sx, sy);

    return 0;
}
```

Python版本：
```python
from collections import deque

def bfs(grid, sx, sy, n, m):
    """BFS广度优先搜索"""
    visited = [[False] * (m + 1) for _ in range(n + 1)]
    dx = [0, 0, 1, -1]
    dy = [1, -1, 0, 0]

    q = deque()
    q.append((sx, sy))
    visited[sx][sy] = True

    while q:
        x, y = q.popleft()
        print(f"访问: {x} {y}")

        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 1 <= nx <= n and 1 <= ny <= m:
                if not visited[nx][ny] and grid[nx][ny] == 0:
                    visited[nx][ny] = True
                    q.append((nx, ny))

# 测试
n, m = map(int, input().split())
grid = [[0] * (m + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    row = list(map(int, input().split()))
    for j in range(1, m + 1):
        grid[i][j] = row[j - 1]

sx, sy = map(int, input().split())
bfs(grid, sx, sy, n, m)
```

应用二：滑动窗口最大值（双端队列）
--------------------------------
使用双端队列(deque)来维护滑动窗口的最大值。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;  // 存储下标，保持递减
    vector<int> result;

    for (int i = 0; i < nums.size(); i++) {
        // 移除超出窗口的元素
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // 保持队列递减
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        // 记录窗口最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }

    return result;
}

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    vector<int> result = maxSlidingWindow(nums, k);

    for (int x : result) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
```

Python版本：
```python
from collections import deque

def max_sliding_window(nums, k):
    """滑动窗口最大值"""
    dq = deque()  # 存储下标，保持递减
    result = []

    for i in range(len(nums)):
        # 移除超出窗口的元素
        while dq and dq[0] <= i - k:
            dq.popleft()

        # 保持队列递减
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()

        dq.append(i)

        # 记录窗口最大值
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# 测试
n, k = map(int, input().split())
nums = list(map(int, input().split()))
result = max_sliding_window(nums, k)
print(' '.join(map(str, result)))
```

应用三：双端队列（Deque）
-------------------------
双端队列允许在两端进行插入和删除操作。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    deque<int> dq;

    // 在队尾插入
    dq.push_back(1);
    dq.push_back(2);

    // 在队头插入
    dq.push_front(0);
    dq.push_front(-1);

    cout << "双端队列: ";
    for (int x : dq) {
        cout << x << " ";
    }
    cout << endl;  // -1 0 1 2

    // 删除队头
    dq.pop_front();

    // 删除队尾
    dq.pop_back();

    cout << "操作后: ";
    for (int x : dq) {
        cout << x << " ";
    }
    cout << endl;  // 0 1

    // 访问队头和队尾
    cout << "队头: " << dq.front() << endl;  // 0
    cout << "队尾: " << dq.back() << endl;   // 1

    return 0;
}
```

Python版本：
```python
from collections import deque

# 双端队列操作
dq = deque()

# 在队尾插入
dq.append(1)
dq.append(2)

# 在队头插入
dq.appendleft(0)
dq.appendleft(-1)

print(f"双端队列: {list(dq)}")  # [-1, 0, 1, 2]

# 删除队头
dq.popleft()

# 删除队尾
dq.pop()

print(f"操作后: {list(dq)}")  # [0, 1]

# 访问队头和队尾
print(f"队头: {dq[0]}")  # 0
print(f"队尾: {dq[-1]}")  # 1
```

应用四：循环队列
---------------
循环队列解决普通队列假溢出的问题。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

class CircularQueue {
private:
    vector<int> data;
    int head;
    int tail;
    int size;
    int capacity;

public:
    CircularQueue(int k) {
        data.resize(k);
        head = 0;
        tail = 0;
        size = 0;
        capacity = k;
    }

    bool enQueue(int value) {
        if (isFull()) return false;
        data[tail] = value;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) return false;
        head = (head + 1) % capacity;
        size--;
        return true;
    }

    int Front() {
        if (isEmpty()) return -1;
        return data[head];
    }

    int Rear() {
        if (isEmpty()) return -1;
        return data[(tail - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};

int main() {
    CircularQueue cq(3);

    cq.enQueue(1);
    cq.enQueue(2);
    cq.enQueue(3);

    cout << "队头: " << cq.Front() << endl;  // 1
    cout << "队尾: " << cq.Rear() << endl;   // 3

    cq.deQueue();
    cq.enQueue(4);

    cout << "操作后队头: " << cq.Front() << endl;  // 2
    cout << "操作后队尾: " << cq.Rear() << endl;   // 4

    return 0;
}
```

Python版本：
```python
class CircularQueue:
    def __init__(self, k):
        self.data = [0] * k
        self.head = 0
        self.tail = 0
        self.size = 0
        self.capacity = k

    def enqueue(self, value):
        """入队"""
        if self.is_full():
            return False
        self.data[self.tail] = value
        self.tail = (self.tail + 1) % self.capacity
        self.size += 1
        return True

    def dequeue(self):
        """出队"""
        if self.is_empty():
            return False
        self.head = (self.head + 1) % self.capacity
        self.size -= 1
        return True

    def front(self):
        """获取队头元素"""
        if self.is_empty():
            return -1
        return self.data[self.head]

    def rear(self):
        """获取队尾元素"""
        if self.is_empty():
            return -1
        return self.data[(self.tail - 1) % self.capacity]

    def is_empty(self):
        """判断队列是否为空"""
        return self.size == 0

    def is_full(self):
        """判断队列是否已满"""
        return self.size == self.capacity

# 测试
cq = CircularQueue(3)
cq.enqueue(1)
cq.enqueue(2)
cq.enqueue(3)

print(f"队头: {cq.front()}")  # 1
print(f"队尾: {cq.rear()}")   # 3

cq.dequeue()
cq.enqueue(4)

print(f"操作后队头: {cq.front()}")  # 2
print(f"操作后队尾: {cq.rear()}")   # 4
```

应用五：优先队列
---------------
优先队列是基于堆实现的队列，元素按优先级出队。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    // 大顶堆（默认）
    priority_queue<int> max_heap;

    max_heap.push(3);
    max_heap.push(1);
    max_heap.push(4);
    max_heap.push(2);

    cout << "大顶堆: ";
    while (!max_heap.empty()) {
        cout << max_heap.top() << " ";
        max_heap.pop();
    }
    cout << endl;  // 4 3 2 1

    // 小顶堆
    priority_queue<int, vector<int>, greater<int>> min_heap;

    min_heap.push(3);
    min_heap.push(1);
    min_heap.push(4);
    min_heap.push(2);

    cout << "小顶堆: ";
    while (!min_heap.empty()) {
        cout << min_heap.top() << " ";
        min_heap.pop();
    }
    cout << endl;  // 1 2 3 4

    return 0;
}
```

Python版本：
```python
import heapq

# Python的heapq默认是小顶堆
min_heap = []
heapq.heappush(min_heap, 3)
heapq.heappush(min_heap, 1)
heapq.heappush(min_heap, 4)
heapq.heappush(min_heap, 2)

print("小顶堆: ", end='')
while min_heap:
    print(heapq.heappop(min_heap), end=' ')
print()  # 1 2 3 4

# 大顶堆（通过取负数实现）
max_heap = []
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -1)
heapq.heappush(max_heap, -4)
heapq.heappush(max_heap, -2)

print("大顶堆: ", end='')
while max_heap:
    print(-heapq.heappop(max_heap), end=' ')
print()  # 4 3 2 1
```

应用六：用队列实现栈
-------------------
使用两个队列来实现栈的结构。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

class MyStack {
private:
    queue<int> q1, q2;

public:
    MyStack() {}

    void push(int x) {
        q2.push(x);
        while (!q1.empty()) {
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1, q2);
    }

    int pop() {
        int val = q1.front();
        q1.pop();
        return val;
    }

    int top() {
        return q1.front();
    }

    bool empty() {
        return q1.empty();
    }
};

int main() {
    MyStack st;

    st.push(1);
    st.push(2);
    st.push(3);

    cout << "栈顶: " << st.top() << endl;  // 3
    st.pop();
    cout << "出栈后栈顶: " << st.top() << endl; // 2

    return 0;
}
```

Python版本：
```python
from collections import deque

class MyStack:
    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, x):
        """入栈"""
        self.q2.append(x)
        while self.q1:
            self.q2.append(self.q1.popleft())
        self.q1, self.q2 = self.q2, self.q1

    def pop(self):
        """出栈"""
        return self.q1.popleft()

    def top(self):
        """获取栈顶元素"""
        return self.q1[0]

    def empty(self):
        """判断栈是否为空"""
        return len(self.q1) == 0

# 测试
st = MyStack()
st.push(1)
st.push(2)
st.push(3)

print(f"栈顶: {st.top()}")  # 3
st.pop()
print(f"出栈后栈顶: {st.top()}")  # 2
```

应用七：用栈实现队列
-------------------
使用两个栈来实现队列的结构。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

class MyQueue {
private:
    stack<int> s1, s2;  // s1用于入队，s2用于出队

    void transfer() {
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
    }

public:
    MyQueue() {}

    void push(int x) {
        s1.push(x);
    }

    int pop() {
        transfer();
        int val = s2.top();
        s2.pop();
        return val;
    }

    int peek() {
        transfer();
        return s2.top();
    }

    bool empty() {
        return s1.empty() && s2.empty();
    }
};

int main() {
    MyQueue q;

    q.push(1);
    q.push(2);
    q.push(3);

    cout << "队头: " << q.peek() << endl;  // 1
    q.pop();
    cout << "出队后队头: " << q.peek() << endl; // 2

    return 0;
}
```

Python版本：
```python
class MyQueue:
    def __init__(self):
        self.s1 = []  # 用于入队
        self.s2 = []  # 用于出队

    def push(self, x):
        """入队"""
        self.s1.append(x)

    def pop(self):
        """出队"""
        self._transfer()
        return self.s2.pop()

    def peek(self):
        """获取队头元素"""
        self._transfer()
        return self.s2[-1]

    def empty(self):
        """判断队列是否为空"""
        return len(self.s1) == 0 and len(self.s2) == 0

    def _transfer(self):
        """将s1的元素转移到s2"""
        if not self.s2:
            while self.s1:
                self.s2.append(self.s1.pop())

# 测试
q = MyQueue()
q.push(1)
q.push(2)
q.push(3)

print(f"队头: {q.peek()}")  # 1
q.pop()
print(f"出队后队头: {q.peek()}")  # 2
```

典型例题
--------
1. 设计循环队列（LeetCode 622）：实现循环队列
2. 滑动窗口最大值（LeetCode 239）：单调队列应用
3. 用栈实现队列（LeetCode 232）：栈实现队列
4. 用队列实现栈（LeetCode 225）：队列实现栈
5. 数据流中的移动平均值（LeetCode 346）：队列应用
6. 最近请求次数（LeetCode 933）：队列应用
7. 完全二叉树的层序遍历（LeetCode 429）：BFS应用
8. 腐烂的橘子（LeetCode 994）：BFS多源搜索

注意事项
--------
1. 数组实现的队列要注意循环队列的判满和判空条件
2. 循环队列通常牺牲一个空间来区分满和空
3. 双端队列(deque)在两端操作都是O(1)时间复杂度
4. 优先队列内部使用堆实现，插入和删除都是O(log n)
5. BFS使用队列实现，要注意visited数组防止重复访问
6. 用两个栈实现队列时，要注意lazy transfer思想

时间复杂度总结
--------------
- 普通队列操作：O(1)
- 循环队列操作：O(1)
- 双端队列操作：O(1)
- 优先队列操作：O(log n)
- 空间复杂度：O(n)

队列是FIFO数据结构的典型代表，在BFS、滑动窗口、任务调度等场景中应用广泛。
