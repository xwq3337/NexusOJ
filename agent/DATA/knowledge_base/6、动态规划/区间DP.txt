区间DP（Interval Dynamic Programming）
====================================

算法概述
--------
区间DP是一种用于解决区间上问题的动态规划技术。通常用于将一个区间分割成若干个子区间，通过合并子区间的结果来得到整个区间的解。

区间DP的特点：
1. 状态定义通常与区间相关，如dp[l][r]表示区间[l, r]的答案
2. 状态转移通常涉及区间分割，将大区间分成小区间
3. 枚举顺序很重要，通常按照区间长度递增的顺序枚举

核心思想
--------
1. 状态定义：dp[l][r] 表示区间[l, r]的最优解
2. 状态转移：枚举分割点k，将区间[l, r]分成[l, k]和[k+1, r]
3. 枚举顺序：先枚举区间长度，再枚举左端点，最后枚举分割点
4. 边界处理：长度为1的区间是边界条件

一、基础模板：石子合并
--------------------

问题描述：
有n堆石子排成一排，每堆石子有一定的质量。现在要将这n堆石子合并成一堆，每次只能合并相邻的两堆石子，合并的代价为两堆石子的质量之和。求最小合并代价。

状态定义：
dp[l][r]：合并区间[l, r]的石子所需的最小代价
sum[l][r]：区间[l, r]的石子总质量

状态转移：
dp[l][r] = min(dp[l][k] + dp[k+1][r] + sum[l][r])，其中l ≤ k < r

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 305;
const int INF = 0x3f3f3f3f;

int n;
int a[MAXN];
int sum[MAXN];      // sum[i]: 前i个石子的总质量
int dp[MAXN][MAXN]; // dp[l][r]: 合并区间[l, r]的最小代价

int main() {
    cin >> n;

    sum[0] = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = sum[i-1] + a[i];
    }

    // 初始化
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 1; i <= n; i++) {
        dp[i][i] = 0;  // 单个石子不需要合并
    }

    // 枚举区间长度
    for (int len = 2; len <= n; len++) {
        // 枚举左端点
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;

            // 枚举分割点
            for (int k = l; k < r; k++) {
                int cost = dp[l][k] + dp[k+1][r] + sum[r] - sum[l-1];
                dp[l][r] = min(dp[l][r], cost);
            }
        }
    }

    cout << dp[1][n] << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    n = int(input())
    a = [0] + list(map(int, input().split()))

    # sum[i]: 前i个石子的总质量
    sum_arr = [0] * (n + 1)
    for i in range(1, n + 1):
        sum_arr[i] = sum_arr[i-1] + a[i]

    # dp[l][r]: 合并区间[l, r]的最小代价
    INF = float('inf')
    dp = [[INF] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dp[i][i] = 0  # 单个石子不需要合并

    # 枚举区间长度
    for length in range(2, n + 1):
        # 枚举左端点
        for l in range(1, n - length + 2):
            r = l + length - 1

            # 枚举分割点
            for k in range(l, r):
                cost = dp[l][k] + dp[k+1][r] + sum_arr[r] - sum_arr[l-1]
                dp[l][r] = min(dp[l][r], cost)

    print(dp[1][n])

solve()
```

二、应用一：括号匹配
------------------

问题描述：
给定一串括号序列，要求添加最少的括号使得序列合法。

状态定义：
dp[l][r]：使区间[l, r]成为合法括号序列所需添加的最少括号数

状态转移：
1. 如果s[l]和s[r]匹配，dp[l][r] = dp[l+1][r-1]
2. 枚举分割点k，dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r])

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

string s;
int dp[MAXN][MAXN];

bool match(char a, char b) {
    return (a == '(' && b == ')') || (a == '[' && b == ']');
}

int main() {
    cin >> s;
    int n = s.length();

    // 初始化
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;  // 单个字符需要添加1个括号
        dp[i][i-1] = 0;  // 空区间不需要添加
    }

    // 枚举区间长度
    for (int len = 2; len <= n; len++) {
        // 枚举左端点
        for (int l = 0; l + len - 1 < n; l++) {
            int r = l + len - 1;

            // 情况1：两端匹配
            if (match(s[l], s[r])) {
                dp[l][r] = dp[l+1][r-1];
            }

            // 情况2：枚举分割点
            for (int k = l; k < r; k++) {
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r]);
            }
        }
    }

    cout << dp[0][n-1] << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    s = input().strip()
    n = len(s)

    # dp[l][r]: 使区间[l, r]成为合法括号序列所需添加的最少括号数
    INF = float('inf')
    dp = [[INF] * n for _ in range(n)]

    for i in range(n):
        dp[i][i] = 1  # 单个字符需要添加1个括号
        if i > 0:
            dp[i][i-1] = 0  # 空区间不需要添加

    def match(a, b):
        return (a == '(' and b == ')') or (a == '[' and b == ']')

    # 枚举区间长度
    for length in range(2, n + 1):
        # 枚举左端点
        for l in range(n - length + 1):
            r = l + length - 1

            # 情况1：两端匹配
            if match(s[l], s[r]):
                dp[l][r] = dp[l+1][r-1]
            else:
                dp[l][r] = INF

            # 情况2：枚举分割点
            for k in range(l, r):
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r])

    print(dp[0][n-1])

solve()
```

三、应用二：括号序列（输出方案）
------------------------------

输出添加括号后的合法序列

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

string s;
int dp[MAXN][MAXN];
int split[MAXN][MAXN];  // split[l][r]: 区间[l, r]的分割点

bool match(char a, char b) {
    return (a == '(' && b == ')') || (a == '[' && b == ']');
}

void print_solution(int l, int r) {
    if (l > r) return;

    if (l == r) {
        if (s[l] == '(' || s[l] == ')') {
            cout << "()";
        } else {
            cout << "[]";
        }
        return;
    }

    if (split[l][r] == -1) {
        // 两端匹配
        cout << s[l];
        print_solution(l + 1, r - 1);
        cout << s[r];
    } else {
        // 需要分割
        print_solution(l, split[l][r]);
        print_solution(split[l][r] + 1, r);
    }
}

int main() {
    cin >> s;
    int n = s.length();

    memset(dp, 0x3f, sizeof(dp));
    memset(split, -1, sizeof(split));

    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
        dp[i][i-1] = 0;
    }

    for (int len = 2; len <= n; len++) {
        for (int l = 0; l + len - 1 < n; l++) {
            int r = l + len - 1;

            if (match(s[l], s[r])) {
                dp[l][r] = dp[l+1][r-1];
                // split[l][r] = -1;  // 已初始化为-1
            }

            for (int k = l; k < r; k++) {
                int cost = dp[l][k] + dp[k+1][r];
                if (cost < dp[l][r]) {
                    dp[l][r] = cost;
                    split[l][r] = k;
                }
            }
        }
    }

    print_solution(0, n - 1);
    cout << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    s = input().strip()
    n = len(s)

    # dp[l][r]: 使区间[l, r]成为合法括号序列所需添加的最少括号数
    INF = float('inf')
    dp = [[INF] * n for _ in range(n)]
    split = [[-1] * n for _ in range(n)]  # split[l][r]: 区间[l, r]的分割点

    for i in range(n):
        dp[i][i] = 1
        if i > 0:
            dp[i][i-1] = 0

    def match(a, b):
        return (a == '(' and b == ')') or (a == '[' and b == ']')

    for length in range(2, n + 1):
        for l in range(n - length + 1):
            r = l + length - 1

            if match(s[l], s[r]):
                dp[l][r] = dp[l+1][r-1]

            for k in range(l, r):
                cost = dp[l][k] + dp[k+1][r]
                if cost < dp[l][r]:
                    dp[l][r] = cost
                    split[l][r] = k

    def print_solution(l, r):
        if l > r:
            return

        if l == r:
            if s[l] == '(' or s[l] == ')':
                print('()', end='')
            else:
                print('[]', end='')
            return

        if split[l][r] == -1:
            # 两端匹配
            print(s[l], end='')
            print_solution(l + 1, r - 1)
            print(s[r], end='')
        else:
            # 需要分割
            print_solution(l, split[l][r])
            print_solution(split[l][r] + 1, r)

    print_solution(0, n - 1)
    print()

solve()
```

四、应用三：矩阵连乘
------------------

问题描述：
给定n个矩阵，每个矩阵的维度已知，计算这些矩阵连乘的最小乘法次数。

状态定义：
dp[l][r]：计算矩阵A[l] × A[l+1] × ... × A[r]的最小乘法次数

状态转移：
dp[l][r] = min(dp[l][k] + dp[k+1][r] + dims[l-1] × dims[k] × dims[r])

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int n;
int dims[MAXN];  // 矩阵维度，矩阵A[i]的维度为dims[i-1] × dims[i]
int dp[MAXN][MAXN];
int split[MAXN][MAXN];

void print_solution(int l, int r) {
    if (l == r) {
        cout << "A" << l;
        return;
    }

    cout << "(";
    print_solution(l, split[l][r]);
    cout << " × ";
    print_solution(split[l][r] + 1, r);
    cout << ")";
}

int main() {
    cin >> n;

    for (int i = 0; i <= n; i++) {
        cin >> dims[i];
    }

    memset(dp, 0x3f, sizeof(dp));
    for (int i = 1; i <= n; i++) {
        dp[i][i] = 0;  // 单个矩阵不需要乘法
    }

    for (int len = 2; len <= n; len++) {
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;

            for (int k = l; k < r; k++) {
                int cost = dp[l][k] + dp[k+1][r] + dims[l-1] * dims[k] * dims[r];
                if (cost < dp[l][r]) {
                    dp[l][r] = cost;
                    split[l][r] = k;
                }
            }
        }
    }

    cout << "最小乘法次数: " << dp[1][n] << endl;
    cout << "最优计算顺序: ";
    print_solution(1, n);
    cout << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    n = int(input())
    dims = list(map(int, input().split()))

    # dp[l][r]: 计算矩阵A[l] × A[l+1] × ... × A[r]的最小乘法次数
    INF = float('inf')
    dp = [[INF] * (n + 1) for _ in range(n + 1)]
    split = [[-1] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dp[i][i] = 0  # 单个矩阵不需要乘法

    for length in range(2, n + 1):
        for l in range(1, n - length + 2):
            r = l + length - 1

            for k in range(l, r):
                cost = dp[l][k] + dp[k+1][r] + dims[l-1] * dims[k] * dims[r]
                if cost < dp[l][r]:
                    dp[l][r] = cost
                    split[l][r] = k

    print(f"最小乘法次数: {dp[1][n]}")

    def print_solution(l, r):
        if l == r:
            return f"A{l}"

        return f"({print_solution(l, split[l][r])} × {print_solution(split[l][r] + 1, r)})"

    print(f"最优计算顺序: {print_solution(1, n)}")

solve()
```

五、应用四：戳气球
----------------

问题描述：
有n个气球，编号为0到n-1，每个气球上有一个数字。戳破气球i可以获得nums[left] × nums[i] × nums[right]个硬币，其中left和right是相邻的气球。求能获得的最大硬币数。

状态定义：
dp[l][r]：戳破区间(l, r)内所有气球能获得的最大硬币数（不包含l和r）

状态转移：
dp[l][r] = max(dp[l][k] + dp[k][r] + nums[l] × nums[k] × nums[r])，其中l < k < r

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 505;
const int INF = 0x3f3f3f3f;

int n;
int nums[MAXN];
int dp[MAXN][MAXN];

int main() {
    cin >> n;

    // 在两端添加虚拟气球
    nums[0] = 1;
    nums[n+1] = 1;
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }

    memset(dp, 0, sizeof(dp));

    // 枚举区间长度
    for (int len = 2; len <= n + 1; len++) {
        // 枚举左端点
        for (int l = 0; l + len <= n + 1; l++) {
            int r = l + len;

            // 枚举最后戳破的气球
            for (int k = l + 1; k < r; k++) {
                int coins = dp[l][k] + dp[k][r] + nums[l] * nums[k] * nums[r];
                dp[l][r] = max(dp[l][r], coins);
            }
        }
    }

    cout << dp[0][n+1] << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    n = int(input())

    # 在两端添加虚拟气球
    nums = [1] + list(map(int, input().split())) + [1]

    # dp[l][r]: 戳破区间(l, r)内所有气球能获得的最大硬币数
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    # 枚举区间长度
    for length in range(2, n + 2):
        # 枚举左端点
        for l in range(n + 2 - length):
            r = l + length

            # 枚举最后戳破的气球
            for k in range(l + 1, r):
                coins = dp[l][k] + dp[k][r] + nums[l] * nums[k] * nums[r]
                dp[l][r] = max(dp[l][r], coins)

    print(dp[0][n+1])

solve()
```

六、应用五：回文子串
------------------

问题描述：
给定一个字符串，求它的最长回文子序列的长度。

状态定义：
dp[l][r]：区间[l, r]的最长回文子序列长度

状态转移：
- 如果s[l] == s[r]：dp[l][r] = dp[l+1][r-1] + 2
- 否则：dp[l][r] = max(dp[l+1][r], dp[l][r-1])

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;

string s;
int dp[MAXN][MAXN];

int main() {
    cin >> s;
    int n = s.length();

    // 初始化
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;  // 单个字符是回文
    }

    // 枚举区间长度
    for (int len = 2; len <= n; len++) {
        // 枚举左端点
        for (int l = 0; l + len - 1 < n; l++) {
            int r = l + len - 1;

            if (s[l] == s[r]) {
                dp[l][r] = dp[l+1][r-1] + 2;
            } else {
                dp[l][r] = max(dp[l+1][r], dp[l][r-1]);
            }
        }
    }

    cout << dp[0][n-1] << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    s = input().strip()
    n = len(s)

    # dp[l][r]: 区间[l, r]的最长回文子序列长度
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
        dp[i][i] = 1  # 单个字符是回文

    # 枚举区间长度
    for length in range(2, n + 1):
        # 枚举左端点
        for l in range(n - length + 1):
            r = l + length - 1

            if s[l] == s[r]:
                dp[l][r] = dp[l+1][r-1] + 2
            else:
                dp[l][r] = max(dp[l+1][r], dp[l][r-1])

    print(dp[0][n-1])

solve()
```

七、应用六：整数划分（乘积最大）
----------------------------

问题描述：
给定一个正整数n，将其拆分成至少两个正整数的和，使这些整数的乘积最大。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;

int n;
int dp[MAXN][MAXN];  // dp[l][r]: 区间[l, r]能获得的最大乘积

int main() {
    cin >> n;

    // dp[i][j]: 将i拆分成至少j个正整数能获得的最大乘积
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1));

    for (int i = 2; i <= n; i++) {
        for (int j = 2; j <= i; j++) {
            // 拆分成j个整数，至少有一个整数是1
            dp[i][j] = dp[i-1][j-1];

            // 或者将某个数继续拆分
            for (int k = 2; k <= i / 2; k++) {
                dp[i][j] = max(dp[i][j], dp[k][1] * dp[i-k][j-1]);
            }
        }
    }

    int max_product = 0;
    for (int j = 2; j <= n; j++) {
        max_product = max(max_product, dp[n][j]);
    }

    cout << max_product << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    n = int(input())

    # dp[i][j]: 将i拆分成至少j个正整数能获得的最大乘积
    dp = [[1] * (n + 1) for _ in range(n + 1)]

    for i in range(2, n + 1):
        for j in range(2, i + 1):
            # 拆分成j个整数，至少有一个整数是1
            dp[i][j] = dp[i-1][j-1]

            # 或者将某个数继续拆分
            for k in range(2, i // 2 + 1):
                dp[i][j] = max(dp[i][j], dp[k][1] * dp[i-k][j-1])

    max_product = max(dp[n][j] for j in range(2, n + 1))
    print(max_product)

solve()
```

典型例题
--------
1. 石子合并（洛谷P1880）：经典区间DP问题
2. 括号匹配（洛谷P1063）：括号序列问题
3. 矩阵连乘（洛谷P1435）：最优计算顺序
4. 戳气球（LeetCode 312）：戳气球问题
5. 最长回文子序列（LeetCode 516）：回文问题
6. 移除盒子（LeetCode 546）：高级区间DP
7. 最少括号添加（POJ 1141）：括号平衡问题

注意事项
--------
1. 枚举顺序：必须按照区间长度递增的顺序枚举
2. 边界处理：注意空区间和单个元素的区间
3. 数组大小：dp数组大小要足够，通常为MAXN × MAXN
4. 初始化：根据题目要求初始化dp数组
5. 状态转移：仔细分析状态转移方程
6. 输出方案：如果需要输出方案，需要记录分割点
7. 时间复杂度：通常为O(n³)，注意数据范围

时间复杂度总结
--------------
- 基础区间DP：O(n³)
- 优化后：某些问题可以优化到O(n²)
- 空间复杂度：O(n²)

区间DP是动态规划中的重要类型，掌握好区间枚举顺序和状态转移是关键。
