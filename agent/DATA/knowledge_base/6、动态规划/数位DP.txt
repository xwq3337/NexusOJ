数位DP（Digit Dynamic Programming）
==================================

算法概述
--------
数位DP是一种用于解决与数字位数相关问题的动态规划技术。通常用于统计在某个区间[L, R]内满足特定条件的数字的个数、求和等问题。

由于区间[L, R]可能很大（如L=1, R=10^100），无法直接枚举，因此需要使用数位DP。

核心思想
--------
1. 将数字按位拆分，逐位进行DP
2. 使用记忆化搜索，记录状态避免重复计算
3. 处理边界条件（前导零、数位上界等）
4. 通过计算[0, N]的答案，然后用f(R) - f(L-1)得到[L, R]的答案

状态设计
--------
典型的状态包含：
- pos: 当前处理到第几位
- lead: 是否有前导零
- limit: 当前位是否受到上界限制
- 其他状态（如前面的数位和、是否有某个数字等）

一、基础模板：统计[0, n]满足条件的数字个数
-----------------------------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<int> digits;
ll dp[20][2];  // dp[pos][lead]: 记忆化数组

// 记忆化搜索
ll dfs(int pos, int lead, int limit) {
    // 边界条件：处理完所有位
    if (pos == (int)digits.size()) {
        return 1;  // 找到一个合法数字
    }

    // 查询记忆化
    if (!limit && !lead && dp[pos][lead] != -1) {
        return dp[pos][lead];
    }

    ll res = 0;
    int max_digit = limit ? digits[pos] : 9;  // 当前位的上界

    for (int d = 0; d <= max_digit; d++) {
        // 处理前导零
        int next_lead = lead && (d == 0);

        // 这里可以添加其他条件判断
        // 例如：if (某个条件) res += dfs(...)

        res += dfs(pos + 1, next_lead, limit && (d == max_digit));
    }

    // 记忆化（只有在无限制且无前导零时才能记忆）
    if (!limit && !lead) {
        dp[pos][lead] = res;
    }

    return res;
}

// 计算区间[0, n]的答案
ll solve(ll n) {
    if (n < 0) return 0;

    digits.clear();
    while (n) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());

    if (digits.empty()) digits.push_back(0);

    memset(dp, -1, sizeof(dp));
    return dfs(0, true, true);
}

int main() {
    ll L, R;
    cin >> L >> R;

    cout << solve(R) - solve(L - 1) << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    digits = []
    dp = {}

    def dfs(pos, lead, limit):
        # 边界条件：处理完所有位
        if pos == len(digits):
            return 1

        # 查询记忆化
        key = (pos, lead, limit)
        if not limit and not lead and key in dp:
            return dp[key]

        res = 0
        max_digit = digits[pos] if limit else 9

        for d in range(max_digit + 1):
            next_lead = lead and (d == 0)
            res += dfs(pos + 1, next_lead, limit and (d == max_digit))

        # 记忆化
        if not limit and not lead:
            dp[key] = res

        return res

    def calc(n):
        if n < 0:
            return 0

        global digits, dp
        digits = []
        while n:
            digits.append(n % 10)
            n //= 10
        digits.reverse()

        if not digits:
            digits = [0]

        dp = {}
        return dfs(0, True, True)

    L, R = map(int, input().split())
    print(calc(R) - calc(L - 1))

solve()
```

二、应用一：统计不含某个数字的个数
-------------------------------

统计区间[L, R]内不包含数字4的数字个数

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<int> digits;
ll dp[20][2];

ll dfs(int pos, int lead, int limit) {
    if (pos == (int)digits.size()) {
        return 1;
    }

    if (!limit && !lead && dp[pos][lead] != -1) {
        return dp[pos][lead];
    }

    ll res = 0;
    int max_digit = limit ? digits[pos] : 9;

    for (int d = 0; d <= max_digit; d++) {
        // 跳过数字4
        if (d == 4) continue;

        int next_lead = lead && (d == 0);
        res += dfs(pos + 1, next_lead, limit && (d == max_digit));
    }

    if (!limit && !lead) {
        dp[pos][lead] = res;
    }

    return res;
}

ll calc(ll n) {
    if (n < 0) return 0;

    digits.clear();
    while (n) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());

    if (digits.empty()) digits.push_back(0);

    memset(dp, -1, sizeof(dp));
    return dfs(0, true, true);
}

int main() {
    ll L, R;
    cin >> L >> R;

    cout << calc(R) - calc(L - 1) << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    digits = []
    dp = {}

    def dfs(pos, lead, limit):
        if pos == len(digits):
            return 1

        key = (pos, lead, limit)
        if not limit and not lead and key in dp:
            return dp[key]

        res = 0
        max_digit = digits[pos] if limit else 9

        for d in range(max_digit + 1):
            if d == 4:  # 跳过数字4
                continue
            next_lead = lead and (d == 0)
            res += dfs(pos + 1, next_lead, limit and (d == max_digit))

        if not limit and not lead:
            dp[key] = res

        return res

    def calc(n):
        if n < 0:
            return 0

        global digits, dp
        digits = []
        while n:
            digits.append(n % 10)
            n //= 10
        digits.reverse()

        if not digits:
            digits = [0]

        dp = {}
        return dfs(0, True, True)

    L, R = map(int, input().split())
    print(calc(R) - calc(L - 1))

solve()
```

三、应用二：统计数位之和等于某个值的数字个数
-----------------------------------------

统计区间[L, R]内数位之和等于target的数字个数

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<int> digits;
ll dp[20][200][2];  // dp[pos][sum][lead]

ll dfs(int pos, int sum, int lead, int limit, int target) {
    if (pos == (int)digits.size()) {
        return sum == target ? 1 : 0;
    }

    if (!limit && !lead && dp[pos][sum][lead] != -1) {
        return dp[pos][sum][lead];
    }

    ll res = 0;
    int max_digit = limit ? digits[pos] : 9;

    for (int d = 0; d <= max_digit; d++) {
        int next_lead = lead && (d == 0);
        int next_sum = next_lead ? 0 : sum + d;
        res += dfs(pos + 1, next_sum, next_lead, limit && (d == max_digit), target);
    }

    if (!limit && !lead) {
        dp[pos][sum][lead] = res;
    }

    return res;
}

ll calc(ll n, int target) {
    if (n < 0) return 0;

    digits.clear();
    while (n) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());

    if (digits.empty()) digits.push_back(0);

    memset(dp, -1, sizeof(dp));
    return dfs(0, 0, true, true, target);
}

int main() {
    ll L, R;
    int target;
    cin >> L >> R >> target;

    cout << calc(R, target) - calc(L - 1, target) << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    digits = []
    dp = {}

    def dfs(pos, sum_val, lead, limit, target):
        if pos == len(digits):
            return 1 if sum_val == target else 0

        key = (pos, sum_val, lead, limit)
        if not limit and not lead and key in dp:
            return dp[key]

        res = 0
        max_digit = digits[pos] if limit else 9

        for d in range(max_digit + 1):
            next_lead = lead and (d == 0)
            next_sum = 0 if next_lead else sum_val + d
            res += dfs(pos + 1, next_sum, next_lead, limit and (d == max_digit), target)

        if not limit and not lead:
            dp[key] = res

        return res

    def calc(n, target):
        if n < 0:
            return 0

        global digits, dp
        digits = []
        while n:
            digits.append(n % 10)
            n //= 10
        digits.reverse()

        if not digits:
            digits = [0]

        dp = {}
        return dfs(0, 0, True, True, target)

    L, R = map(int, input().split())
    target = int(input())
    print(calc(R, target) - calc(L - 1, target))

solve()
```

四、应用三：Windy数
------------------

Windy数定义：不含前导零且相邻两个数字之差的绝对值至少为2的正整数

统计区间[L, R]内Windy数的个数

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<int> digits;
ll dp[20][15][2];  // dp[pos][last_digit][lead]

ll dfs(int pos, int last_digit, int lead, int limit) {
    if (pos == (int)digits.size()) {
        return lead ? 0 : 1;  // 前导零不算Windy数
    }

    if (!limit && !lead && dp[pos][last_digit][lead] != -1) {
        return dp[pos][last_digit][lead];
    }

    ll res = 0;
    int max_digit = limit ? digits[pos] : 9;

    for (int d = 0; d <= max_digit; d++) {
        int next_lead = lead && (d == 0);

        if (next_lead) {
            res += dfs(pos + 1, d, next_lead, limit && (d == max_digit));
        } else {
            // 检查相邻数字差是否>=2
            if (lead || abs(d - last_digit) >= 2) {
                res += dfs(pos + 1, d, next_lead, limit && (d == max_digit));
            }
        }
    }

    if (!limit && !lead) {
        dp[pos][last_digit][lead] = res;
    }

    return res;
}

ll calc(ll n) {
    if (n < 0) return 0;

    digits.clear();
    while (n) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());

    if (digits.empty()) digits.push_back(0);

    memset(dp, -1, sizeof(dp));
    return dfs(0, 0, true, true);
}

int main() {
    ll L, R;
    cin >> L >> R;

    cout << calc(R) - calc(L - 1) << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    digits = []
    dp = {}

    def dfs(pos, last_digit, lead, limit):
        if pos == len(digits):
            return 0 if lead else 1

        key = (pos, last_digit, lead, limit)
        if not limit and not lead and key in dp:
            return dp[key]

        res = 0
        max_digit = digits[pos] if limit else 9

        for d in range(max_digit + 1):
            next_lead = lead and (d == 0)

            if next_lead:
                res += dfs(pos + 1, d, next_lead, limit and (d == max_digit))
            else:
                if lead or abs(d - last_digit) >= 2:
                    res += dfs(pos + 1, d, next_lead, limit and (d == max_digit))

        if not limit and not lead:
            dp[key] = res

        return res

    def calc(n):
        if n < 0:
            return 0

        global digits, dp
        digits = []
        while n:
            digits.append(n % 10)
            n //= 10
        digits.reverse()

        if not digits:
            digits = [0]

        dp = {}
        return dfs(0, 0, True, True)

    L, R = map(int, input().split())
    print(calc(R) - calc(L - 1))

solve()
```

五、应用四：数字计数
-----------------

统计区间[L, R]内每个数字（0-9）出现的次数

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<int> digits;
ll dp[20][10][2][2];  // dp[pos][last_digit][lead][has_started]

pair<ll, ll> dfs(int pos, int cnt, int lead, int limit, int target) {
    if (pos == (int)digits.size()) {
        return {cnt, 1};
    }

    if (!limit && dp[pos][cnt][lead][0] != -1) {
        return {dp[pos][cnt][lead][0], dp[pos][cnt][lead][1]};
    }

    ll total_cnt = 0, total_num = 0;
    int max_digit = limit ? digits[pos] : 9;

    for (int d = 0; d <= max_digit; d++) {
        int next_lead = lead && (d == 0);
        int next_cnt = cnt + (!next_lead && d == target ? 1 : 0);

        auto [child_cnt, child_num] = dfs(pos + 1, next_cnt, next_lead,
                                           limit && (d == max_digit), target);

        total_cnt += child_cnt;
        total_num += child_num;
    }

    if (!limit) {
        dp[pos][cnt][lead][0] = total_cnt;
        dp[pos][cnt][lead][1] = total_num;
    }

    return {total_cnt, total_num};
}

ll calc(ll n, int target) {
    if (n < 0) return 0;

    digits.clear();
    while (n) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());

    if (digits.empty()) digits.push_back(0);

    memset(dp, -1, sizeof(dp));
    auto [cnt, num] = dfs(0, 0, true, true, target);

    return cnt;
}

int main() {
    ll L, R;
    cin >> L >> R;

    for (int d = 0; d <= 9; d++) {
        cout << calc(R, d) - calc(L - 1, d) << " ";
    }
    cout << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    digits = []
    dp = {}

    def dfs(pos, cnt, lead, limit, target):
        if pos == len(digits):
            return cnt, 1

        key = (pos, cnt, lead, limit)
        if not limit and key in dp:
            return dp[key]

        total_cnt = 0
        total_num = 0
        max_digit = digits[pos] if limit else 9

        for d in range(max_digit + 1):
            next_lead = lead and (d == 0)
            next_cnt = cnt + (0 if next_lead or d != target else 1)

            child_cnt, child_num = dfs(pos + 1, next_cnt, next_lead,
                                       limit and (d == max_digit), target)

            total_cnt += child_cnt
            total_num += child_num

        if not limit:
            dp[key] = (total_cnt, total_num)

        return total_cnt, total_num

    def calc(n, target):
        if n < 0:
            return 0

        global digits, dp
        digits = []
        while n:
            digits.append(n % 10)
            n //= 10
        digits.reverse()

        if not digits:
            digits = [0]

        dp = {}
        cnt, num = dfs(0, 0, True, True, target)

        return cnt

    L, R = map(int, input().split())
    result = []
    for d in range(10):
        result.append(str(calc(R, d) - calc(L - 1, d)))

    print(' '.join(result))

solve()
```

六、应用五：不降数
----------------

统计区间[L, R]内各位数字从左到右不下降的数字个数

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<int> digits;
ll dp[20][15][2];  // dp[pos][last_digit][lead]

ll dfs(int pos, int last_digit, int lead, int limit) {
    if (pos == (int)digits.size()) {
        return 1;
    }

    if (!limit && !lead && dp[pos][last_digit][lead] != -1) {
        return dp[pos][last_digit][lead];
    }

    ll res = 0;
    int max_digit = limit ? digits[pos] : 9;

    for (int d = 0; d <= max_digit; d++) {
        int next_lead = lead && (d == 0);

        if (next_lead) {
            res += dfs(pos + 1, d, next_lead, limit && (d == max_digit));
        } else {
            // 当前数字>=前一个数字
            if (lead || d >= last_digit) {
                res += dfs(pos + 1, d, next_lead, limit && (d == max_digit));
            }
        }
    }

    if (!limit && !lead) {
        dp[pos][last_digit][lead] = res;
    }

    return res;
}

ll calc(ll n) {
    if (n < 0) return 0;

    digits.clear();
    while (n) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());

    if (digits.empty()) digits.push_back(0);

    memset(dp, -1, sizeof(dp));
    return dfs(0, 0, true, true);
}

int main() {
    ll L, R;
    cin >> L >> R;

    cout << calc(R) - calc(L - 1) << endl;

    return 0;
}
```

Python版本：
```python
def solve():
    digits = []
    dp = {}

    def dfs(pos, last_digit, lead, limit):
        if pos == len(digits):
            return 1

        key = (pos, last_digit, lead, limit)
        if not limit and not lead and key in dp:
            return dp[key]

        res = 0
        max_digit = digits[pos] if limit else 9

        for d in range(max_digit + 1):
            next_lead = lead and (d == 0)

            if next_lead:
                res += dfs(pos + 1, d, next_lead, limit and (d == max_digit))
            else:
                if lead or d >= last_digit:
                    res += dfs(pos + 1, d, next_lead, limit and (d == max_digit))

        if not limit and not lead:
            dp[key] = res

        return res

    def calc(n):
        if n < 0:
            return 0

        global digits, dp
        digits = []
        while n:
            digits.append(n % 10)
            n //= 10
        digits.reverse()

        if not digits:
            digits = [0]

        dp = {}
        return dfs(0, 0, True, True)

    L, R = map(int, input().split())
    print(calc(R) - calc(L - 1))

solve()
```

典型例题
--------
1. Windy数（洛谷P2657）：相邻数字差>=2的数字
2. 数字计数（洛谷P2602）：统计每个数字出现次数
3. 不降数（洛谷P2657）：数字不下降
4. 数字游戏（洛谷P2656）：数位游戏问题
5. 度的数量（洛谷P4127）：特定进制下满足条件的数
6. Phone Numbers（Codeforces 940C）：构造数字问题

注意事项
--------
1. 前导零的处理：前导零不应该参与条件判断
2. 边界条件：处理n=0的情况
3. 记忆化时机：只有在无限制时才能记忆化
4. 状态设计：根据题目要求设计合适的状态
5. 递归深度：注意数字位数不要太多
6. 区间查询：使用f(R) - f(L-1)计算
7. long long：数字很大时使用long long

时间复杂度总结
--------------
- 状态数：O(位数 × 状态维度)
- 转移：O(10)
- 总复杂度：O(位数 × 状态维度 × 10)
- 通常：O(10 × 20 × 状态维度)

数位DP是一种重要的DP技巧，掌握好记忆化搜索和状态设计是关键。
