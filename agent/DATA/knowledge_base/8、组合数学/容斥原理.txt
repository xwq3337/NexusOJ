容斥原理（Inclusion-Exclusion Principle）
=======================================

算法概述
--------
容斥原理是组合数学中最重要的计数原理之一，用于计算多个集合的并集大小。
基本思想：先计算所有情况的和，然后减去重复计算的部分，再加上多减的部分，依此类推。

核心公式
--------
对于两个集合A和B：
|A ∪ B| = |A| + |B| - |A ∩ B|

对于三个集合A、B、C：
|A ∪ B ∪ C| = |A| + |B| + |C| - |A ∩ B| - |A ∩ C| - |B ∩ C| + |A ∩ B ∩ C|

一般形式（n个集合）：
|A₁ ∪ A₂ ∪ ... ∪ Aₙ| = Σ|Ai| - Σ|Ai ∩ Aj| + Σ|Ai ∩ Aj ∩ Ak| - ... + (-1)^(n+1) |A₁ ∩ A₂ ∩ ... ∩ Aₙ|

补集形式：
|A₁' ∩ A₂' ∩ ... ∩ Aₙ'| = |U| - |A₁ ∪ A₂ ∪ ... ∪ Aₙ|

基础应用一：简单的集合并集
---------------------------
计算两个或三个集合的并集大小。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    // 示例：计算能被2、3、5整除的数的个数
    int n;
    cin >> n;

    int cnt2 = n / 2;      // 能被2整除
    int cnt3 = n / 3;      // 能被3整除
    int cnt5 = n / 5;      // 能被5整除
    int cnt6 = n / 6;      // 能被2和3整除
    int cnt10 = n / 10;    // 能被2和5整除
    int cnt15 = n / 15;    // 能被3和5整除
    int cnt30 = n / 30;    // 能被2、3、5整除

    // 容斥原理
    int ans = cnt2 + cnt3 + cnt5 - cnt6 - cnt10 - cnt15 + cnt30;
    cout << ans << '\n';

    return 0;
}
```

Python版本：
```python
def solve():
    n = int(input())

    cnt2 = n // 2
    cnt3 = n // 3
    cnt5 = n // 5
    cnt6 = n // 6
    cnt10 = n // 10
    cnt15 = n // 15
    cnt30 = n // 30

    ans = cnt2 + cnt3 + cnt5 - cnt6 - cnt10 - cnt15 + cnt30
    print(ans)

solve()
```

基础应用二：互质数的个数
-----------------------
计算1到n中与m互质的数的个数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

// 计算1到n中与m互质的数的个数
int count_coprime(int n, int m) {
    // 分解质因数
    vector<int> primes;
    int temp = m;
    for (int i = 2; i * i <= temp; i++) {
        if (temp % i == 0) {
            primes.push_back(i);
            while (temp % i == 0) {
                temp /= i;
            }
        }
    }
    if (temp > 1) {
        primes.push_back(temp);
    }

    // 容斥原理
    int k = primes.size();
    int ans = 0;

    for (int mask = 1; mask < (1 << k); mask++) {
        int bits = 0;
        int product = 1;
        for (int i = 0; i < k; i++) {
            if (mask & (1 << i)) {
                bits++;
                product *= primes[i];
            }
        }
        int cnt = n / product;
        if (bits % 2 == 1) {
            ans += cnt;
        } else {
            ans -= cnt;
        }
    }

    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << count_coprime(n, m) << '\n';

    return 0;
}
```

Python版本：
```python
def count_coprime(n, m):
    # 分解质因数
    primes = []
    temp = m
    i = 2
    while i * i <= temp:
        if temp % i == 0:
            primes.append(i)
            while temp % i == 0:
                temp //= i
        i += 1
    if temp > 1:
        primes.append(temp)

    # 容斥原理
    k = len(primes)
    ans = 0

    for mask in range(1, 1 << k):
        bits = 0
        product = 1
        for i in range(k):
            if mask & (1 << i):
                bits += 1
                product *= primes[i]
        cnt = n // product
        if bits % 2 == 1:
            ans += cnt
        else:
            ans -= cnt

    return ans

def main():
    n, m = map(int, input().split())
    print(count_coprime(n, m))

if __name__ == "__main__":
    main()
```

基础应用三：错位排列（Derangement）
-----------------------------------
求n个元素的错位排列数，即所有元素都不在原位置的排列数。

公式：D(n) = n! * (1 - 1/1! + 1/2! - 1/3! + ... + (-1)^n / n!)
     或者：D(n) = (n-1) * (D(n-1) + D(n-2))

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000005;
const int MOD = 1e9 + 7;

long long fact[MAXN];
long long derangement[MAXN];

// 快速幂
long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = fact[i-1] * i % MOD;
    }

    derangement[0] = 1;
    derangement[1] = 0;
    for (int i = 2; i < MAXN; i++) {
        derangement[i] = (i - 1) * (derangement[i-1] + derangement[i-2]) % MOD;
    }
}

int main() {
    init();

    int n;
    cin >> n;
    cout << derangement[n] << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7
MAXN = 1000005

def init():
    fact = [1] * MAXN
    for i in range(1, MAXN):
        fact[i] = fact[i-1] * i % MOD

    derangement = [1] * MAXN
    derangement[1] = 0
    for i in range(2, MAXN):
        derangement[i] = (i - 1) * (derangement[i-1] + derangement[i-2]) % MOD

    return derangement

def main():
    derangement = init()
    n = int(input())
    print(derangement[n])

if __name__ == "__main__":
    main()
```

进阶应用一：球盒问题（容斥版本）
-------------------------------
将n个不同的球放入m个不同的盒子中，每个盒子至少放一个球。

答案：m^n - C(m,1)*(m-1)^n + C(m,2)*(m-2)^n - ... + (-1)^(m-1)*C(m,m-1)*1^n

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 计算C(n, m)
long long C(long long n, long long m) {
    if (m < 0 || m > n) return 0;
    if (m > n - m) m = n - m;

    long long res = 1;
    for (long long i = 1; i <= m; i++) {
        res = res * (n - m + i) % MOD;
        res = res * qpow(i, MOD - 2) % MOD;
    }
    return res;
}

// 容斥原理计算满射数量
long long count_surjection(int n, int m) {
    long long ans = 0;
    for (int i = 0; i <= m; i++) {
        long long term = C(m, i) * qpow(m - i, n) % MOD;
        if (i % 2 == 0) {
            ans = (ans + term) % MOD;
        } else {
            ans = (ans - term + MOD) % MOD;
        }
    }
    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << count_surjection(n, m) << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

def qpow(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def C(n, m):
    if m < 0 or m > n:
        return 0
    if m > n - m:
        m = n - m

    res = 1
    for i in range(1, m + 1):
        res = res * (n - m + i) % MOD
        res = res * qpow(i, MOD - 2) % MOD
    return res

def count_surjection(n, m):
    ans = 0
    for i in range(m + 1):
        term = C(m, i) * qpow(m - i, n) % MOD
        if i % 2 == 0:
            ans = (ans + term) % MOD
        else:
            ans = (ans - term + MOD) % MOD
    return ans

def main():
    n, m = map(int, input().split())
    print(count_surjection(n, m))

if __name__ == "__main__":
    main()
```

进阶应用二：多重集组合数（带限制）
-----------------------------------
从n种物品中选择，每种物品有数量限制，求选m个物品的方案数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 25;
const int MOD = 1e9 + 7;

int n, m;
int limit[MAXN];

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

long long C(long long n, long long m) {
    if (m < 0 || m > n) return 0;
    if (m > n - m) m = n - m;

    long long res = 1;
    for (long long i = 1; i <= m; i++) {
        res = res * (n - m + i) % MOD;
        res = res * qpow(i, MOD - 2) % MOD;
    }
    return res;
}

long long count_combinations() {
    long long ans = 0;
    for (int mask = 0; mask < (1 << n); mask++) {
        long long sum = m + n - 1;  // 初始：C(m+n-1, n-1)
        int bits = 0;

        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                bits++;
                sum -= (limit[i] + 1);
            }
        }

        if (sum >= n - 1) {
            long long term = C(sum, n - 1);
            if (bits % 2 == 0) {
                ans = (ans + term) % MOD;
            } else {
                ans = (ans - term + MOD) % MOD;
            }
        }
    }
    return ans;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> limit[i];
    }

    cout << count_combinations() << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

def qpow(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def C(n, m):
    if m < 0 or m > n:
        return 0
    if m > n - m:
        m = n - m

    res = 1
    for i in range(1, m + 1):
        res = res * (n - m + i) % MOD
        res = res * qpow(i, MOD - 2) % MOD
    return res

def count_combinations(n, m, limit):
    ans = 0
    for mask in range(1 << n):
        sum_val = m + n - 1
        bits = 0

        for i in range(n):
            if mask & (1 << i):
                bits += 1
                sum_val -= (limit[i] + 1)

        if sum_val >= n - 1:
            term = C(sum_val, n - 1)
            if bits % 2 == 0:
                ans = (ans + term) % MOD
            else:
                ans = (ans - term + MOD) % MOD
    return ans

def main():
    n, m = map(int, input().split())
    limit = list(map(int, input().split()))
    print(count_combinations(n, m, limit))

if __name__ == "__main__":
    main()
```

典型例题一：满足条件的子集个数
------------------------------
给定一个数集，求能被给定某些数整除的数的个数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    vector<int> nums = {2, 3, 5, 7};  // 给定的数
    cin >> n;

    int k = nums.size();
    int ans = 0;

    for (int mask = 1; mask < (1 << k); mask++) {
        int bits = 0;
        int lcm_val = 1;

        for (int i = 0; i < k; i++) {
            if (mask & (1 << i)) {
                bits++;
                lcm_val = lcm(lcm_val, nums[i]);
            }
        }

        int cnt = n / lcm_val;
        if (bits % 2 == 1) {
            ans += cnt;
        } else {
            ans -= cnt;
        }
    }

    cout << ans << '\n';

    return 0;
}
```

Python版本：
```python
import math

def solve():
    n = int(input())
    nums = [2, 3, 5, 7]

    k = len(nums)
    ans = 0

    for mask in range(1, 1 << k):
        bits = 0
        lcm_val = 1

        for i in range(k):
            if mask & (1 << i):
                bits += 1
                lcm_val = math.lcm(lcm_val, nums[i])

        cnt = n // lcm_val
        if bits % 2 == 1:
            ans += cnt
        else:
            ans -= cnt

    print(ans)

solve()
```

典型例题二：整数方程的解的个数
------------------------------
求方程 x₁ + x₂ + ... + xₙ = m 的非负整数解的个数，其中 xᵢ ≤ aᵢ。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

long long C(long long n, long long m) {
    if (m < 0 || m > n) return 0;
    if (m > n - m) m = n - m;

    long long res = 1;
    for (long long i = 1; i <= m; i++) {
        res = res * (n - m + i) % MOD;
        res = res * qpow(i, MOD - 2) % MOD;
    }
    return res;
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    long long ans = 0;
    for (int mask = 0; mask < (1 << n); mask++) {
        int bits = 0;
        int sum = m;

        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                bits++;
                sum -= (a[i] + 1);
            }
        }

        if (sum >= 0) {
            long long term = C(sum + n - 1, n - 1);
            if (bits % 2 == 0) {
                ans = (ans + term) % MOD;
            } else {
                ans = (ans - term + MOD) % MOD;
            }
        }
    }

    cout << ans << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

def qpow(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def C(n, m):
    if m < 0 or m > n:
        return 0
    if m > n - m:
        m = n - m

    res = 1
    for i in range(1, m + 1):
        res = res * (n - m + i) % MOD
        res = res * qpow(i, MOD - 2) % MOD
    return res

def main():
    n, m = map(int, input().split())
    a = list(map(int, input().split()))

    ans = 0
    for mask in range(1 << n):
        bits = 0
        sum_val = m

        for i in range(n):
            if mask & (1 << i):
                bits += 1
                sum_val -= (a[i] + 1)

        if sum_val >= 0:
            term = C(sum_val + n - 1, n - 1)
            if bits % 2 == 0:
                ans = (ans + term) % MOD
            else:
                ans = (ans - term + MOD) % MOD

    print(ans)

if __name__ == "__main__":
    main()
```

重要性质总结
------------
1. 容斥原理通过交替加减来处理重叠问题
2. 符号规律：奇数个集合取交集时为负，偶数个时为正
3. 对于补集问题，可以先计算并集再用总数减去
4. 当约束条件较多时，使用二进制枚举子集
5. 注意边界条件和特例的处理

应用场景
--------
1. 计算满足至少一个条件的元素个数
2. 计算满足多个限制条件的方案数
3. 错位排列问题
4. 互质数的计数
5. 整数方程的解的个数（带限制）
6. 球盒问题（每个盒子至少一个球）

注意事项
--------
1. 使用二进制枚举时，注意枚举范围是2^n
2. 计算交集时可能需要用到LCM（最小公倍数）
3. 注意模运算，特别是减法时要加MOD防止负数
4. 当n较大时（n > 20），需要考虑优化方法
5. 有些问题可以用生成函数等其他方法解决
6. 注意判断条件的奇偶性，正确应用加减

时间复杂度总结
--------------
- 对于n个条件：O(2^n) 枚举所有子集
- 单次容斥计算：O(n)
- 总时间复杂度：O(n * 2^n)

容斥原理是解决组合计数问题的重要工具，特别是处理"至少"、"恰好"等条件时非常有效。
