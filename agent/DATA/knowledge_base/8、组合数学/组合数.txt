组合数（Combination）
===================

算法概述
--------
组合数C(n, m)表示从n个不同元素中取出m个元素的组合数，是组合数学中最基础的概念。
组合数的计算涉及多个重要知识点：基本公式、杨辉三角、模意义下的组合数、Lucas定理等。

核心概念
--------
1. 组合数定义：C(n, m) = n! / (m! * (n-m)!)
2. 递推公式：C(n, m) = C(n-1, m-1) + C(n-1, m)
3. 对称性：C(n, m) = C(n, n-m)
4. 杨辉三角：第n行第m列的值就是C(n, m)

基础应用一：组合数计算（递推法）
--------------------------------
使用递推公式计算组合数，基于杨辉三角的思想。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2005;
const int MOD = 1e9 + 7;

int n, m;
long long C[MAXN][MAXN];

// 预处理组合数
void init() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = C[i][i] = 1;  // 边界条件
        for (int j = 1; j < i; j++) {
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}

int main() {
    init();

    int t;
    cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        cout << C[n][m] << '\n';
    }

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7
MAXN = 2005

def init_combination():
    C = [[0] * MAXN for _ in range(MAXN)]
    for i in range(MAXN):
        C[i][0] = C[i][i] = 1
        for j in range(1, i):
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD
    return C

def main():
    C = init_combination()
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        print(C[n][m])

if __name__ == "__main__":
    main()
```

基础应用二：组合数计算（阶乘逆元法）
------------------------------------
当n较大时，使用阶乘+逆元的方法计算单个组合数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000005;
const int MOD = 1e9 + 7;

long long fact[MAXN];  // 阶乘
long long invfact[MAXN];  // 阶乘的逆元

// 快速幂
long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 预处理阶乘和逆元
void init() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = fact[i-1] * i % MOD;
    }

    invfact[MAXN-1] = qpow(fact[MAXN-1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) {
        invfact[i] = invfact[i+1] * (i + 1) % MOD;
    }
}

// 计算C(n, m)
long long C(int n, int m) {
    if (m < 0 || m > n) return 0;
    return fact[n] * invfact[m] % MOD * invfact[n-m] % MOD;
}

int main() {
    init();

    int n, m;
    cin >> n >> m;
    cout << C(n, m) << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7
MAXN = 1000005

def qpow(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def init():
    fact = [1] * MAXN
    for i in range(1, MAXN):
        fact[i] = fact[i-1] * i % MOD

    invfact = [1] * MAXN
    invfact[MAXN-1] = qpow(fact[MAXN-1], MOD - 2)
    for i in range(MAXN - 2, -1, -1):
        invfact[i] = invfact[i+1] * (i + 1) % MOD

    return fact, invfact

def C(n, m, fact, invfact):
    if m < 0 or m > n:
        return 0
    return fact[n] * invfact[m] % MOD * invfact[n-m] % MOD

def main():
    fact, invfact = init()
    n, m = map(int, input().split())
    print(C(n, m, fact, invfact))

if __name__ == "__main__":
    main()
```

基础应用三：杨辉三角输出
-----------------------
输出杨辉三角的前n行。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 35;

int n;
long long C[MAXN][MAXN];

int main() {
    cin >> n;

    for (int i = 0; i < n; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; j++) {
            C[i][j] = C[i-1][j-1] + C[i-1][j];
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            cout << C[i][j] << " ";
        }
        cout << '\n';
    }

    return 0;
}
```

Python版本：
```python
def print_pascal_triangle(n):
    C = [[0] * n for _ in range(n)]
    for i in range(n):
        C[i][0] = C[i][i] = 1
        for j in range(1, i):
            C[i][j] = C[i-1][j-1] + C[i-1][j]

    for i in range(n):
        for j in range(i + 1):
            print(C[i][j], end=" ")
        print()

def main():
    n = int(input())
    print_pascal_triangle(n)

if __name__ == "__main__":
    main()
```

进阶应用：Lucas定理（详见Lucas定理.txt）
---------------------------------------
Lucas定理用于处理模数p较小时的组合数计算。
对于质数p，C(n, m) mod p = C(n mod p, m mod p) * C(n/p, m/p) mod p

C++版本（简化版）：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e5 + 3;  // 质数

long long fact[MOD];
long long invfact[MOD];

long long qpow(long long a, long long b, long long mod) {
    long long res = 1;
    a %= mod;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void init(long long mod) {
    fact[0] = 1;
    for (int i = 1; i < mod; i++) {
        fact[i] = fact[i-1] * i % mod;
    }
    invfact[(int)mod - 1] = qpow(fact[(int)mod - 1], mod - 2, mod);
    for (int i = (int)mod - 2; i >= 0; i--) {
        invfact[i] = invfact[i+1] * (i + 1) % mod;
    }
}

long long C(long long n, long long m, long long mod) {
    if (m < 0 || m > n) return 0;
    return fact[n] * invfact[m] % mod * invfact[n-m] % mod;
}

// Lucas定理
long long lucas(long long n, long long m, long long mod) {
    if (m == 0) return 1;
    return C(n % mod, m % mod, mod) * lucas(n / mod, m / mod, mod) % mod;
}

int main() {
    init(MOD);

    long long n, m;
    cin >> n >> m;
    cout << lucas(n, m, MOD) << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**5 + 3

def qpow(a, b, mod):
    res = 1
    a %= mod
    while b:
        if b & 1:
            res = res * a % mod
        a = a * a % mod
        b >>= 1
    return res

def init(mod):
    fact = [1] * mod
    for i in range(1, mod):
        fact[i] = fact[i-1] * i % mod

    invfact = [1] * mod
    invfact[mod - 1] = qpow(fact[mod - 1], mod - 2, mod)
    for i in range(mod - 2, -1, -1):
        invfact[i] = invfact[i + 1] * (i + 1) % mod

    return fact, invfact

def C_small(n, m, mod, fact, invfact):
    if m < 0 or m > n:
        return 0
    return fact[n] * invfact[m] % mod * invfact[n - m] % mod

def lucas(n, m, mod, fact, invfact):
    if m == 0:
        return 1
    return C_small(n % mod, m % mod, mod, fact, invfact) * \
           lucas(n // mod, m // mod, mod, fact, invfact) % mod

def main():
    mod = MOD
    fact, invfact = init(mod)
    n, m = map(int, input().split())
    print(lucas(n, m, mod, fact, invfact))

if __name__ == "__main__":
    main()
```

典型例题一：路径计数
--------------------
在一个n×m的网格中，从左上角走到右下角，只能向右或向下走，有多少种不同的路径？

思路：总共需要走(n-1)次向下和(m-1)次向右，共n+m-2步，从中选出n-1步向下。
答案：C(n+m-2, n-1)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 2005;

long long C[MAXN][MAXN];

void init() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; j++) {
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}

int main() {
    init();

    int n, m;
    cin >> n >> m;
    cout << C[n+m-2][n-1] << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7
MAXN = 2005

def init():
    C = [[0] * MAXN for _ in range(MAXN)]
    for i in range(MAXN):
        C[i][0] = C[i][i] = 1
        for j in range(1, i):
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD
    return C

def main():
    C = init()
    n, m = map(int, input().split())
    print(C[n+m-2][n-1])

if __name__ == "__main__":
    main()
```

典型例题二：隔板法
------------------
将n个相同的球放入m个不同的盒子中，每个盒子至少放一个球，有多少种放法？

思路：使用隔板法，在n-1个间隙中插入m-1个隔板。
答案：C(n-1, m-1)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

long long C(long long n, long long m, long long mod) {
    if (m < 0 || m > n) return 0;
    if (m > n - m) m = n - m;

    long long res = 1;
    for (long long i = 1; i <= m; i++) {
        res = res * (n - m + i) % mod;
        res = res * qpow(i, mod - 2) % mod;
    }
    return res;
}

int main() {
    long long n, m;
    cin >> n >> m;
    cout << C(n - 1, m - 1, MOD) << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7

def qpow(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def C(n, m, mod=MOD):
    if m < 0 or m > n:
        return 0
    if m > n - m:
        m = n - m

    res = 1
    for i in range(1, m + 1):
        res = res * (n - m + i) % mod
        res = res * qpow(i, mod - 2) % mod
    return res

def main():
    n, m = map(int, input().split())
    print(C(n - 1, m - 1))

if __name__ == "__main__":
    main()
```

典型例题三：二项式定理应用
--------------------------
计算 (a + b)^n 展开式中第k项的系数。

答案：C(n, k-1) * a^(n-k+1) * b^(k-1)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 1005;

long long C[MAXN][MAXN];

void init() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; j++) {
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    init();

    long long a, b;
    int n, k;
    cin >> a >> b >> n >> k;

    long long coeff = C[n][k-1];
    long long term_a = qpow(a % MOD, n - k + 1);
    long long term_b = qpow(b % MOD, k - 1);

    cout << coeff * term_a % MOD * term_b % MOD << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7
MAXN = 1005

def init():
    C = [[0] * MAXN for _ in range(MAXN)]
    for i in range(MAXN):
        C[i][0] = C[i][i] = 1
        for j in range(1, i):
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD
    return C

def qpow(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def main():
    C = init()
    a, b = map(int, input().split())
    n, k = map(int, input().split())

    coeff = C[n][k-1]
    term_a = qpow(a % MOD, n - k + 1)
    term_b = qpow(b % MOD, k - 1)

    print(coeff * term_a % MOD * term_b % MOD)

if __name__ == "__main__":
    main()
```

典型例题四：组合数求和
----------------------
计算 sum(C(i, k)) for i = k to n

利用组合数性质：sum(C(i, k)) = C(n+1, k+1)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 2005;

long long C[MAXN][MAXN];

void init() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; j++) {
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}

int main() {
    init();

    int n, k;
    cin >> n >> k;

    // sum(C(i, k)) for i = k to n = C(n+1, k+1)
    cout << C[n+1][k+1] << '\n';

    return 0;
}
```

Python版本：
```python
MOD = 10**9 + 7
MAXN = 2005

def init():
    C = [[0] * MAXN for _ in range(MAXN)]
    for i in range(MAXN):
        C[i][0] = C[i][i] = 1
        for j in range(1, i):
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD
    return C

def main():
    C = init()
    n, k = map(int, input().split())
    print(C[n+1][k+1])

if __name__ == "__main__":
    main()
```

重要性质总结
------------
1. 对称性：C(n, m) = C(n, n-m)
2. 递推式：C(n, m) = C(n-1, m-1) + C(n-1, m)
3. 吸收式：C(n, m) = C(n, m-1) * (n-m+1) / m
4. 范德蒙德卷积：sum(C(i, r) * C(n-i, m-r)) = C(n+1, m+1)
5. 二项式定理：(a+b)^n = sum(C(n, i) * a^i * b^(n-i))

注意事项
--------
1. 计算组合数时注意数据范围，防止溢出
2. 模意义下的计算需要使用逆元
3. 递推法适合多组查询且范围较小的情况
4. 阶乘逆元法适合单次查询但n较大的情况
5. Lucas定理适合模数p较小但n非常大的情况
6. 注意组合数的定义域：0 <= m <= n
7. 使用long long防止中间结果溢出

时间复杂度总结
--------------
- 递推法预处理：O(n^2)，单次查询：O(1)
- 阶乘逆元法预处理：O(n)，单次查询：O(1)
- Lucas定理：O(log_p(n)) 每次查询

组合数是组合数学的基础，掌握其各种计算方法对解决相关问题至关重要。
