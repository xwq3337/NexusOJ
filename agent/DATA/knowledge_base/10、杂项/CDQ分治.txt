CDQ分治（CDQ Divide and Conquer）
================================

算法概述
--------
CDQ分治是一种特殊的分治算法，由中国OI选手陈丹琦（CDQ）提出。
它主要用于优化动态规划的转移过程，将原本O(n²)的复杂度优化到O(n log n)。

核心思想
--------
1. 分治：将区间[l, r]分成[l, mid]和[mid+1, r]
2. 处理：递归处理左半部分和右半部分
3. 合并：计算左半部分对右半部分的影响

关键特点
--------
- 时间有序性：CDQ分治利用了时间顺序的性质
- 离线处理：通常将所有操作存储后统一处理
- 降维打击：将多维问题转化为一维问题处理

基础应用：三维偏序
------------------
给定三维坐标(x, y, z)，求每个点的偏序数（有多少点在它前面）。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

struct Point {
    int x, y, z, id;
} p[MAXN], tmp[MAXN];

int n, ans[MAXN];
int bit[MAXN];

// 树状数组
void add(int x, int val) {
    for (; x < MAXN; x += x & (-x)) {
        bit[x] += val;
    }
}

int query(int x) {
    int res = 0;
    for (; x > 0; x -= x & (-x)) {
        res += bit[x];
    }
    return res;
}

// CDQ分治
void cdq(int l, int r) {
    if (l == r) return;

    int mid = (l + r) / 2;
    cdq(l, mid);
    cdq(mid + 1, r);

    // 按y坐标排序
    sort(p + l, p + r + 1,
         [](Point a, Point b) { return a.y < b.y; });

    // 处理左半部分对右半部分的影响
    for (int i = l; i <= r; i++) {
        if (i <= mid) {
            add(p[i].z, 1);
        } else {
            ans[p[i].id] += query(p[i].z);
        }
    }

    // 清空树状数组
    for (int i = l; i <= mid; i++) {
        add(p[i].z, -1);
    }
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> p[i].x >> p[i].y >> p[i].z;
        p[i].id = i;
    }

    // 按x坐标排序
    sort(p + 1, p + n + 1,
         [](Point a, Point b) { return a.x < b.x; });

    memset(ans, 0, sizeof(ans));
    cdq(1, n);

    for (int i = 1; i <= n; i++) {
        cout << ans[i] << '\n';
    }

    return 0;
}
```

Python版本：
```python
def cdq(points, l, r, bit):
    if l == r:
        return

    mid = (l + r) // 2
    cdq(points, l, mid, bit)
    cdq(points, mid + 1, r, bit)

    # 按y坐标排序
    points[l:r+1] = sorted(points[l:r+1], key=lambda p: p[1])

    # 处理左半部分对右半部分的影响
    for i in range(l, r + 1):
        if i <= mid:
            # 更新树状数组
            z = points[i][2]
            idx = z
            while idx < len(bit):
                bit[idx] += 1
                idx += idx & (-idx)
        else:
            # 查询
            z = points[i][2]
            idx = z
            cnt = 0
            while idx > 0:
                cnt += bit[idx]
                idx -= idx & (-idx)
            points[i][3] += cnt

    # 清空树状数组
    for i in range(l, mid + 1):
        z = points[i][2]
        idx = z
        while idx < len(bit):
            bit[idx] -= 1
            idx += idx & (-idx)

def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    points = []
    for i in range(n):
        x, y, z = map(int, input().split())
        points.append([x, y, z, 0])  # id存储在index 3

    # 按x坐标排序
    points.sort(key=lambda p: p[0])

    bit = [0] * (max(p[2] for p in points) + 2)
    cdq(points, 0, n - 1, bit)

    for p in points:
        print(p[3])

if __name__ == "__main__":
    main()
```

典型应用一：动态规划优化
----------------------
优化形如dp[i] = max(dp[j] + val[j][i])的转移，其中j < i。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int dp[MAXN];
pair<int, int> p[MAXN];  // (position, value)

struct Event {
    int type;  // 0: query, 1: update
    int x, y, val;
} events[MAXN * 2];

int bit[MAXN];

void add(int x, int val) {
    for (; x < MAXN; x += x & (-x)) {
        bit[x] = max(bit[x], val);
    }
}

int query(int x) {
    int res = 0;
    for (; x > 0; x -= x & (-x)) {
        res = max(res, bit[x]);
    }
    return res;
}

void cdq(int l, int r) {
    if (l == r) return;

    int mid = (l + r) / 2;
    cdq(l, mid);
    cdq(mid + 1, r);

    // 左半部分更新，右半部分查询
    for (int i = l; i <= r; i++) {
        if (i <= mid) {
            add(events[i].y, events[i].val);
        } else {
            dp[events[i].x] = max(dp[events[i].x], query(events[i].y));
        }
    }

    // 清空树状数组
    for (int i = l; i <= mid; i++) {
        add(events[i].y, 0);
    }
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> p[i].first >> p[i].second;
    }

    // 按位置排序
    sort(p + 1, p + n + 1);

    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        events[++cnt] = {1, i, p[i].first, dp[i]};
        events[++cnt] = {0, i, p[i].second, 0};
    }

    cdq(1, cnt);

    cout << *max_element(dp + 1, dp + n + 1) << '\n';

    return 0;
}
```

Python版本：
```python
def cdq(events, l, r, bit):
    if l == r:
        return

    mid = (l + r) // 2
    cdq(events, l, mid, bit)
    cdq(events, mid + 1, r, bit)

    # 左半部分更新，右半部分查询
    for i in range(l, r + 1):
        if i <= mid:
            # update
            y = events[i]['y']
            val = events[i]['val']
            idx = y
            while idx < len(bit):
                bit[idx] = max(bit[idx], val)
                idx += idx & (-idx)
        else:
            # query
            y = events[i]['y']
            idx = y
            res = 0
            while idx > 0:
                res = max(res, bit[idx])
                idx -= idx & (-idx)
            dp[events[i]['x']] = max(dp[events[i]['x']], res)

    # 清空
    for i in range(l, mid + 1):
        y = events[i]['y']
        idx = y
        while idx < len(bit):
            bit[idx] = 0
            idx += idx & (-idx)

def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    p = []
    for i in range(n):
        pos, val = map(int, input().split())
        p.append((pos, val))

    p.sort()

    dp = [0] * (n + 1)
    events = []

    for i in range(n):
        events.append({'type': 1, 'x': i + 1, 'y': p[i][0], 'val': dp[i + 1]})
        events.append({'type': 0, 'x': i + 1, 'y': p[i][1], 'val': 0})

    max_y = max(e['y'] for e in events)
    bit = [0] * (max_y + 2)

    cdq(events, 0, len(events) - 1, bit)

    print(max(dp[1:]))

if __name__ == "__main__":
    main()
```

典型应用二：区间修改查询
----------------------
支持区间加、区间求和的数据结构。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n, q;
long long a[MAXN], ans[MAXN];

struct Operation {
    int type;  // 0: query, 1: modify
    int l, r, id;
    long long val;
} op[MAXN * 2], tmp[MAXN * 2];

long long bit[MAXN];

void add(int x, long long val) {
    for (; x < MAXN; x += x & (-x)) {
        bit[x] += val;
    }
}

long long query(int x) {
    long long res = 0;
    for (; x > 0; x -= x & (-x)) {
        res += bit[x];
    }
    return res;
}

void cdq(int l, int r) {
    if (l == r) return;

    int mid = (l + r) / 2;
    cdq(l, mid);
    cdq(mid + 1, r);

    // 处理左边修改对右边查询的影响
    for (int i = l; i <= r; i++) {
        tmp[i] = op[i];
    }

    int i = l, j = mid + 1, k = l;
    while (i <= mid && j <= r) {
        if (tmp[i].l <= tmp[j].l) {
            if (tmp[i].type == 1) {
                add(tmp[i].r, tmp[i].val);
            }
            op[k++] = tmp[i++];
        } else {
            if (tmp[j].type == 0) {
                ans[tmp[j].id] += query(tmp[j].r) - query(tmp[j].l - 1);
            }
            op[k++] = tmp[j++];
        }
    }

    while (i <= mid) {
        if (tmp[i].type == 1) {
            add(tmp[i].r, tmp[i].val);
        }
        op[k++] = tmp[i++];
    }

    while (j <= r) {
        if (tmp[j].type == 0) {
            ans[tmp[j].id] += query(tmp[j].r) - query(tmp[j].l - 1);
        }
        op[k++] = tmp[j++];
    }

    // 清空树状数组
    for (int i = l; i <= mid; i++) {
        if (tmp[i].type == 1) {
            add(tmp[i].r, -tmp[i].val);
        }
    }
}

int main() {
    cin >> n >> q;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    int cnt = 0;
    for (int i = 1; i <= q; i++) {
        int type;
        cin >> type;
        if (type == 1) {
            int l, r;
            long long val;
            cin >> l >> r >> val;
            op[++cnt] = {1, l, r, i, val};
        } else {
            int l, r;
            cin >> l >> r;
            op[++cnt] = {0, l, r, i, 0};
        }
    }

    cdq(1, cnt);

    for (int i = 1; i <= q; i++) {
        if (ans[i] != 0 || op[i].type == 0) {
            cout << ans[i] << '\n';
        }
    }

    return 0;
}
```

Python版本：
```python
def cdq(op, l, r, bit):
    if l == r:
        return

    mid = (l + r) // 2
    cdq(op, l, mid, bit)
    cdq(op, mid + 1, r, bit)

    tmp = op[l:r+1]
    i, j, k = l, mid + 1, l

    while i <= mid and j <= r:
        if tmp[i - l]['l'] <= tmp[j - l]['l']:
            if tmp[i - l]['type'] == 1:
                # update
                pos = tmp[i - l]['r']
                val = tmp[i - l]['val']
                idx = pos
                while idx < len(bit):
                    bit[idx] += val
                    idx += idx & (-idx)
            op[k] = tmp[i - l]
            i += 1
        else:
            if tmp[j - l]['type'] == 0:
                # query
                l_pos = tmp[j - l]['l']
                r_pos = tmp[j - l]['r']
                ans[tmp[j - l]['id']] += query(r_pos, bit) - query(l_pos - 1, bit)
            op[k] = tmp[j - l]
            j += 1
        k += 1

    while i <= mid:
        if tmp[i - l]['type'] == 1:
            pos = tmp[i - l]['r']
            val = tmp[i - l]['val']
            idx = pos
            while idx < len(bit):
                bit[idx] += val
                idx += idx & (-idx)
        op[k] = tmp[i - l]
        i += 1
        k += 1

    while j <= r:
        if tmp[j - l]['type'] == 0:
            l_pos = tmp[j - l]['l']
            r_pos = tmp[j - l]['r']
            ans[tmp[j - l]['id']] += query(r_pos, bit) - query(l_pos - 1, bit)
        op[k] = tmp[j - l]
        j += 1
        k += 1

    # 清空
    for i in range(l, mid + 1):
        if tmp[i - l]['type'] == 1:
            pos = tmp[i - l]['r']
            val = tmp[i - l]['val']
            idx = pos
            while idx < len(bit):
                bit[idx] -= val
                idx += idx & (-idx)

def query(x, bit):
    res = 0
    while x > 0:
        res += bit[x]
        x -= x & (-x)
    return res

def main():
    import sys
    input = sys.stdin.readline

    n, q = map(int, input().split())
    a = list(map(int, input().split()))

    op = []
    for i in range(q):
        parts = list(map(int, input().split()))
        if parts[0] == 1:
            op.append({'type': 1, 'l': parts[1], 'r': parts[2], 'id': i, 'val': parts[3]})
        else:
            op.append({'type': 0, 'l': parts[1], 'r': parts[2], 'id': i, 'val': 0})

    max_r = max(o['r'] for o in op)
    bit = [0] * (max_r + 2)

    ans = [0] * q
    cdq(op, 0, len(op) - 1, bit)

    for i in range(q):
        if ans[i] != 0 or op[i]['type'] == 0:
            print(ans[i])

if __name__ == "__main__":
    main()
```

典型应用三：斜率优化DP
---------------------
优化形如dp[i] = min(dp[j] + cost(j+1, i))的转移。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
long long dp[MAXN], sum[MAXN];

struct Query {
    int l, r;
    long long x, y;
} q[MAXN], tmp[MAXN];

long long get_y(int j, long long x) {
    return dp[j] + sum[j] * sum[j] - 2 * sum[j] * x;
}

void cdq(int l, int r) {
    if (l == r) {
        dp[l] = dp[l-1] + (sum[l] - sum[l-1]) * (sum[l] - sum[l-1]);
        return;
    }

    int mid = (l + r) / 2;
    cdq(l, mid);

    // 上凸壳优化
    int top = 0;
    for (int i = l; i <= mid; i++) {
        while (top > 1 && (q[top].y - q[top-1].y) * (i - q[top].x) >=
                           (q[top].x - q[top-1].x) * (dp[i] + sum[i] * sum[i] - q[top].y)) {
            top--;
        }
        top++;
        q[top].x = sum[i];
        q[top].y = dp[i] + sum[i] * sum[i];
    }

    for (int i = mid + 1; i <= r; i++) {
        int lo = 1, hi = top;
        while (lo < hi) {
            int mid1 = (lo + hi) / 2;
            if (q[mid1].y - 2 * sum[i] * q[mid1].x > q[mid1+1].y - 2 * sum[i] * q[mid1+1].x) {
                lo = mid1 + 1;
            } else {
                hi = mid1;
            }
        }
        dp[i] = min(dp[i], q[lo].y - 2 * sum[i] * q[lo].x + sum[i] * sum[i]);
    }

    cdq(mid + 1, r);
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        sum[i] = sum[i-1] + x;
    }

    memset(dp, 0x3f, sizeof(dp));
    dp[0] = 0;

    cdq(1, n);

    cout << dp[n] << '\n';

    return 0;
}
```

Python版本：
```python
def cdq(l, r, dp, sum_val):
    if l == r:
        dp[l] = dp[l-1] + (sum_val[l] - sum_val[l-1]) ** 2
        return

    mid = (l + r) // 2
    cdq(l, mid, dp, sum_val)

    # 上凸壳优化
    q = []
    for i in range(l, mid + 1):
        while len(q) > 1:
            x1, y1 = q[-2]
            x2, y2 = q[-1]
            if (y2 - y1) * (sum_val[i] - x2) >= (x2 - x1) * (dp[i] + sum_val[i] ** 2 - y2):
                q.pop()
            else:
                break
        q.append((sum_val[i], dp[i] + sum_val[i] ** 2))

    for i in range(mid + 1, r + 1):
        lo, hi = 0, len(q) - 1
        while lo < hi:
            mid1 = (lo + hi) // 2
            if q[mid1][1] - 2 * sum_val[i] * q[mid1][0] > q[mid1+1][1] - 2 * sum_val[i] * q[mid1+1][0]:
                lo = mid1 + 1
            else:
                hi = mid1
        dp[i] = min(dp[i], q[lo][1] - 2 * sum_val[i] * q[lo][0] + sum_val[i] ** 2)

    cdq(mid + 1, r, dp, sum_val)

def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    arr = list(map(int, input().split()))

    sum_val = [0] * (n + 1)
    for i in range(1, n + 1):
        sum_val[i] = sum_val[i-1] + arr[i-1]

    dp = [float('inf')] * (n + 1)
    dp[0] = 0

    cdq(1, n, dp, sum_val)

    print(dp[n])

if __name__ == "__main__":
    main()
```

算法特点总结
------------
1. 离线处理：需要提前知道所有操作
2. 时间优化：通常将O(n²)优化到O(n log n)
3. 空间换时间：需要额外的数据结构（如树状数组）
4. 分治思想：利用分治的性质优化转移

应用场景
--------
1. 三维偏序问题
2. 动态规划优化
3. 区间修改查询
4. 斜率优化DP
5. 逆序对计数

注意事项
--------
1. 必须满足时间有序性
2. 需要离线处理所有操作
3. 注意数据结构的清空
4. 边界条件的处理
5. 可能需要多次CDQ分治

时间复杂度总结
--------------
- 基础CDQ：O(n log n)
- 带数据结构：O(n log² n)
- 多层CDQ：O(n log^k n)，k为CDQ层数

CDQ分治是一种强大的算法优化技术，特别适合处理有序性和转移类问题，在竞赛中应用广泛。
