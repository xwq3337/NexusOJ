约瑟夫问题（Josephus Problem）
=============================

算法概述
--------
约瑟夫问题是一个著名的数学问题：n个人围成一圈，从某个指定的人开始报数，
数到k的那个人就被淘汰，接着从下一个人重新开始报数，数到k的人再被淘汰，
以此类推，直到所有人都被淘汰。求最后剩下的人的编号。

问题变种
--------
1. 基础版本：求最后剩下的人
2. 递归版本：记录淘汰顺序
3. 优化版本：O(k)或O(log n)解法

基础解法：模拟
-------------
时间复杂度：O(nk)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int josephus(int n, int k) {
    list<int> people;
    for (int i = 0; i < n; i++) {
        people.push_back(i);
    }

    auto it = people.begin();
    while (people.size() > 1) {
        for (int i = 1; i < k; i++) {
            it++;
            if (it == people.end()) {
                it = people.begin();
            }
        }
        it = people.erase(it);
        if (it == people.end()) {
            it = people.begin();
        }
    }

    return people.front();
}

int main() {
    int n, k;
    cin >> n >> k;
    cout << josephus(n, k) << '\n';

    return 0;
}
```

Python版本：
```python
def josephus(n, k):
    people = list(range(n))
    idx = 0

    while len(people) > 1:
        idx = (idx + k - 1) % len(people)
        people.pop(idx)

    return people[0]

def main():
    n, k = map(int, input().split())
    print(josephus(n, k))

if __name__ == "__main__":
    main()
```

优化解法一：递归公式
-------------------
时间复杂度：O(n)

递推公式：J(n, k) = (J(n-1, k) + k) % n
初始条件：J(1, k) = 0

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int josephus(int n, int k) {
    if (n == 1) {
        return 0;
    }
    return (josephus(n - 1, k) + k) % n;
}

int main() {
    int n, k;
    cin >> n >> k;
    cout << josephus(n, k) + 1 << '\n';  // 转换为1-based

    return 0;
}
```

Python版本：
```python
def josephus(n, k):
    if n == 1:
        return 0
    return (josephus(n - 1, k) + k) % n

def main():
    n, k = map(int, input().split())
    print(josephus(n, k) + 1)  # 转换为1-based

if __name__ == "__main__":
    main()
```

优化解法二：迭代版本
-------------------
时间复杂度：O(n)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int josephus(int n, int k) {
    int result = 0;  // J(1, k) = 0
    for (int i = 2; i <= n; i++) {
        result = (result + k) % i;
    }
    return result;
}

int main() {
    int n, k;
    cin >> n >> k;
    cout << josephus(n, k) + 1 << '\n';

    return 0;
}
```

Python版本：
```python
def josephus(n, k):
    result = 0  # J(1, k) = 0
    for i in range(2, n + 1):
        result = (result + k) % i
    return result

def main():
    n, k = map(int, input().split())
    print(josephus(n, k) + 1)

if __name__ == "__main__":
    main()
```

典型应用一：k=2的特殊情况
-----------------------
当k=2时，有O(1)的解法。

如果n = 2^m + l，其中0 ≤ l < 2^m，则J(n, 2) = 2l + 1

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int josephus_k2(int n) {
    // 找到最大的2的幂
    int m = 1;
    while (m * 2 <= n) {
        m *= 2;
    }
    int l = n - m;
    return 2 * l + 1;
}

int main() {
    int n;
    cin >> n;
    cout << josephus_k2(n) << '\n';

    return 0;
}
```

Python版本：
```python
def josephus_k2(n):
    # 找到最大的2的幂
    m = 1
    while m * 2 <= n:
        m *= 2
    l = n - m
    return 2 * l + 1

def main():
    n = int(input())
    print(josephus_k2(n))

if __name__ == "__main__":
    main()
```

典型应用二：记录淘汰顺序
----------------------
求所有人的淘汰顺序。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> josephus_order(int n, int k) {
    vector<int> result;
    list<int> people;

    for (int i = 0; i < n; i++) {
        people.push_back(i);
    }

    auto it = people.begin();
    while (!people.empty()) {
        for (int i = 1; i < k; i++) {
            it++;
            if (it == people.end()) {
                it = people.begin();
            }
        }
        result.push_back(*it);
        it = people.erase(it);
        if (it == people.end() && !people.empty()) {
            it = people.begin();
        }
    }

    return result;
}

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> order = josephus_order(n, k);

    for (int x : order) {
        cout << x + 1 << " ";
    }
    cout << '\n';

    return 0;
}
```

Python版本：
```python
def josephus_order(n, k):
    people = list(range(n))
    result = []
    idx = 0

    while people:
        idx = (idx + k - 1) % len(people)
        result.append(people.pop(idx))

    return result

def main():
    n, k = map(int, input().split())
    order = josephus_order(n, k)
    print([x + 1 for x in order])

if __name__ == "__main__":
    main()
```

典型应用三：求第m个被淘汰的人
---------------------------
给定n和k，求第m个被淘汰的人的编号。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int josephus_mth(int n, int k, int m) {
    if (m == n) {
        // 最后剩下的人
        int result = 0;
        for (int i = 2; i <= n; i++) {
            result = (result + k) % i;
        }
        return result;
    }

    // 模拟前m-1次淘汰
    list<int> people;
    for (int i = 0; i < n; i++) {
        people.push_back(i);
    }

    auto it = people.begin();
    for (int i = 0; i < m - 1; i++) {
        for (int j = 1; j < k; j++) {
            it++;
            if (it == people.end()) {
                it = people.begin();
            }
        }
        it = people.erase(it);
        if (it == people.end()) {
            it = people.begin();
        }
    }

    // 找第m个
    for (int i = 1; i < k; i++) {
        it++;
        if (it == people.end()) {
            it = people.begin();
        }
    }

    return *it;
}

int main() {
    int n, k, m;
    cin >> n >> k >> m;
    cout << josephus_mth(n, k, m) + 1 << '\n';

    return 0;
}
```

Python版本：
```python
def josephus_mth(n, k, m):
    if m == n:
        # 最后剩下的人
        result = 0
        for i in range(2, n + 1):
            result = (result + k) % i
        return result

    # 模拟
    people = list(range(n))
    idx = 0

    for _ in range(m - 1):
        idx = (idx + k - 1) % len(people)
        people.pop(idx)

    idx = (idx + k - 1) % len(people)
    return people[idx]

def main():
    n, k, m = map(int, input().split())
    print(josephus_mth(n, k, m) + 1)

if __name__ == "__main__":
    main()
```

典型应用四：反向约瑟夫问题
------------------------
给定最后剩下的人的编号，求n。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int reverse_josephus(int survivor, int k, int max_n) {
    for (int n = 1; n <= max_n; n++) {
        int result = 0;
        for (int i = 2; i <= n; i++) {
            result = (result + k) % i;
        }
        if (result == survivor - 1) {
            return n;
        }
    }
    return -1;
}

int main() {
    int survivor, k, max_n;
    cin >> survivor >> k >> max_n;
    cout << reverse_josephus(survivor, k, max_n) << '\n';

    return 0;
}
```

Python版本：
```python
def reverse_josephus(survivor, k, max_n):
    for n in range(1, max_n + 1):
        result = 0
        for i in range(2, n + 1):
            result = (result + k) % i
        if result == survivor - 1:
            return n
    return -1

def main():
    survivor, k, max_n = map(int, input().split())
    print(reverse_josephus(survivor, k, max_n))

if __name__ == "__main__":
    main()
```

进阶应用：多组约瑟夫问题
----------------------
同时处理多组查询。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int dp[MAXN];

void precompute(int k) {
    dp[1] = 0;
    for (int i = 2; i < MAXN; i++) {
        dp[i] = (dp[i-1] + k) % i;
    }
}

int main() {
    int k;
    cin >> k;

    precompute(k);

    int q;
    cin >> q;

    while (q--) {
        int n;
        cin >> n;
        cout << dp[n] + 1 << '\n';
    }

    return 0;
}
```

Python版本：
```python
def precompute(k, max_n):
    dp = [0] * (max_n + 1)
    for i in range(2, max_n + 1):
        dp[i] = (dp[i-1] + k) % i
    return dp

def main():
    import sys
    input = sys.stdin.readline

    k = int(input())
    max_n = 100000
    dp = precompute(k, max_n)

    q = int(input())
    for _ in range(q):
        n = int(input())
        print(dp[n] + 1)

if __name__ == "__main__":
    main()
```

数学性质总结
------------
1. J(1, k) = 0
2. J(n, k) = (J(n-1, k) + k) % n
3. J(2^m, 2) = 1
4. 当k=2时：如果n = 2^m + l，则J(n, 2) = 2l + 1

应用场景
--------
1. 资源分配问题
2. 任务调度问题
3. 游戏设计
4. 密码学
5. 算法竞赛

注意事项
--------
1. 注意编号是0-based还是1-based
2. 当k很大时，可能需要优化
3. 递归深度可能过大，建议使用迭代
4. 对于多组查询，可以预计算

时间复杂度总结
--------------
- 模拟法：O(nk)
- 递归/迭代：O(n)
- k=2特殊情况：O(1)或O(log n)
- 预处理：O(max_n)，单次查询O(1)

约瑟夫问题是算法中的经典问题，其优美的递推性质和多种解法使其成为学习递归和动态规划的绝佳例题。
