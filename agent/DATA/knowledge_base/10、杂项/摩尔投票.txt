摩尔投票算法（Boyer-Moore Voting Algorithm）
==========================================

算法概述
--------
摩尔投票算法是一种用于在序列中查找多数元素的线性时间算法。
多数元素定义为在序列中出现次数超过⌊n/2⌋的元素。

核心思想
--------
利用"对消"的思想：每次从序列中删除两个不同的元素，多数元素最终会留下来。

基础版本：查找多数元素
-----------------------
时间复杂度：O(n)，空间复杂度：O(1)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int majorityElement(vector<int>& nums) {
    int candidate = nums[0];
    int count = 1;

    for (int i = 1; i < nums.size(); i++) {
        if (count == 0) {
            candidate = nums[i];
            count = 1;
        } else if (nums[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }

    return candidate;
}

int main() {
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << majorityElement(nums) << '\n';

    return 0;
}
```

Python版本：
```python
def majority_element(nums):
    candidate = nums[0]
    count = 1

    for num in nums[1:]:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1

    return candidate

def main():
    n = int(input())
    nums = list(map(int, input().split()))
    print(majority_element(nums))

if __name__ == "__main__":
    main()
```

完整版本：验证多数元素
-----------------------
在某些情况下，可能不存在多数元素，需要验证。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int findCandidate(vector<int>& nums) {
    int candidate = nums[0];
    int count = 1;

    for (int i = 1; i < nums.size(); i++) {
        if (count == 0) {
            candidate = nums[i];
            count = 1;
        } else if (nums[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }

    return candidate;
}

bool isMajority(vector<int>& nums, int candidate) {
    int count = 0;
    for (int num : nums) {
        if (num == candidate) {
            count++;
        }
    }
    return count > nums.size() / 2;
}

int main() {
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    int candidate = findCandidate(nums);

    if (isMajority(nums, candidate)) {
        cout << "Majority element: " << candidate << '\n';
    } else {
        cout << "No majority element\n";
    }

    return 0;
}
```

Python版本：
```python
def find_candidate(nums):
    candidate = nums[0]
    count = 1

    for num in nums[1:]:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1

    return candidate

def is_majority(nums, candidate):
    count = sum(1 for num in nums if num == candidate)
    return count > len(nums) // 2

def main():
    n = int(input())
    nums = list(map(int, input().split()))

    candidate = find_candidate(nums)

    if is_majority(nums, candidate):
        print(f"Majority element: {candidate}")
    else:
        print("No majority element")

if __name__ == "__main__":
    main()
```

扩展应用：查找所有出现次数超过n/3的元素
---------------------------------------
使用推广的摩尔投票算法。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> majorityElement(vector<int>& nums) {
    vector<int> result;

    if (nums.empty()) return result;

    // 初始化两个候选者
    int candidate1 = nums[0], candidate2 = nums[0];
    int count1 = 0, count2 = 0;

    // 第一遍：找出两个候选者
    for (int num : nums) {
        if (num == candidate1) {
            count1++;
        } else if (num == candidate2) {
            count2++;
        } else if (count1 == 0) {
            candidate1 = num;
            count1 = 1;
        } else if (count2 == 0) {
            candidate2 = num;
            count2 = 1;
        } else {
            count1--;
            count2--;
        }
    }

    // 第二遍：验证候选者
    count1 = count2 = 0;
    for (int num : nums) {
        if (num == candidate1) count1++;
        else if (num == candidate2) count2++;
    }

    int n = nums.size();
    if (count1 > n / 3) result.push_back(candidate1);
    if (count2 > n / 3) result.push_back(candidate2);

    return result;
}

int main() {
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    vector<int> result = majorityElement(nums);
    for (int x : result) {
        cout << x << " ";
    }
    cout << '\n';

    return 0;
}
```

Python版本：
```python
def majority_element(nums):
    if not nums:
        return []

    # 初始化两个候选者
    candidate1 = candidate2 = nums[0]
    count1 = count2 = 0

    # 第一遍：找出两个候选者
    for num in nums:
        if num == candidate1:
            count1 += 1
        elif num == candidate2:
            count2 += 1
        elif count1 == 0:
            candidate1 = num
            count1 = 1
        elif count2 == 0:
            candidate2 = num
            count2 = 1
        else:
            count1 -= 1
            count2 -= 1

    # 第二遍：验证候选者
    count1 = count2 = 0
    for num in nums:
        if num == candidate1:
            count1 += 1
        elif num == candidate2:
            count2 += 1

    result = []
    n = len(nums)
    if count1 > n // 3:
        result.append(candidate1)
    if count2 > n // 3:
        result.append(candidate2)

    return result

def main():
    n = int(input())
    nums = list(map(int, input().split()))

    result = majority_element(nums)
    print(result)

if __name__ == "__main__":
    main()
```

典型应用一：寻找主元素
----------------------
给定大小为n的数组，找到出现次数最多的元素。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int findMajority(vector<int>& nums) {
    int candidate = nums[0];
    int count = 1;

    for (int i = 1; i < nums.size(); i++) {
        if (count == 0) {
            candidate = nums[i];
            count = 1;
        } else if (nums[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }

    return candidate;
}

int main() {
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << findMajority(nums) << '\n';

    return 0;
}
```

Python版本：
```python
def find_majority(nums):
    candidate = nums[0]
    count = 1

    for num in nums[1:]:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1

    return candidate

def main():
    n = int(input())
    nums = list(map(int, input().split()))
    print(find_majority(nums))

if __name__ == "__main__":
    main()
```

典型应用二：在线算法
--------------------
数据以流的形式到达，无法存储所有数据，求多数元素。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int candidate = 0;
    int count = 0;
    int x;

    while (cin >> x) {
        if (count == 0) {
            candidate = x;
            count = 1;
        } else if (x == candidate) {
            count++;
        } else {
            count--;
        }
    }

    cout << "Majority element: " << candidate << '\n';

    return 0;
}
```

Python版本：
```python
def online_majority():
    candidate = None
    count = 0

    while True:
        try:
            x = int(input())
            if count == 0:
                candidate = x
                count = 1
            elif x == candidate:
                count += 1
            else:
                count -= 1
        except EOFError:
            break

    print(f"Majority element: {candidate}")

if __name__ == "__main__":
    online_majority()
```

典型应用三：检查是否可以重排使相邻元素不同
-----------------------------------------
给定数组，判断是否可以重排使得相邻元素不同。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

bool canReorganizeString(string s) {
    int n = s.length();

    // 统计每个字符的出现次数
    int count[26] = {0};
    for (char c : s) {
        count[c - 'a']++;
    }

    // 使用摩尔投票找到出现次数最多的字符
    int max_count = 0;
    char max_char = 'a';
    for (int i = 0; i < 26; i++) {
        if (count[i] > max_count) {
            max_count = count[i];
            max_char = 'a' + i;
        }
    }

    // 如果出现次数最多的字符超过(n+1)/2，则无法重排
    if (max_count > (n + 1) / 2) {
        return false;
    }

    return true;
}

int main() {
    string s;
    cin >> s;

    if (canReorganizeString(s)) {
        cout << "YES\n";
    } else {
        cout << "NO\n";
    }

    return 0;
}
```

Python版本：
```python
def can_reorganize_string(s):
    n = len(s)

    # 统计每个字符的出现次数
    count = [0] * 26
    for c in s:
        count[ord(c) - ord('a')] += 1

    # 找到出现次数最多的字符
    max_count = max(count)

    # 如果出现次数最多的字符超过(n+1)/2，则无法重排
    if max_count > (n + 1) // 2:
        return False

    return True

def main():
    s = input().strip()

    if can_reorganize_string(s):
        print("YES")
    else:
        print("NO")

if __name__ == "__main__":
    main()
```

算法原理分析
------------
1. 对消原理：不同元素相互抵消，多数元素最终会留下
2. 配对删除：每次删除一对不同的元素，不影响多数元素的地位
3. 计数机制：用count表示当前候选者的"优势"

重要性质
--------
1. 时间复杂度：O(n)
2. 空间复杂度：O(1)
3. 只需要遍历数组一次或两次
4. 适用于查找出现次数超过⌊n/k⌋的元素（需要k-1个候选者）

扩展：通用摩尔投票算法
----------------------
查找所有出现次数超过n/k的元素。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> majorityElement(vector<int>& nums, int k) {
    vector<int> result;

    if (nums.empty()) return result;

    // k-1个候选者
    vector<int> candidates(k - 1, INT_MIN);
    vector<int> counts(k - 1, 0);

    // 第一遍：找出候选者
    for (int num : nums) {
        bool found = false;
        for (int i = 0; i < k - 1; i++) {
            if (candidates[i] == num) {
                counts[i]++;
                found = true;
                break;
            }
        }

        if (!found) {
            for (int i = 0; i < k - 1; i++) {
                if (counts[i] == 0) {
                    candidates[i] = num;
                    counts[i] = 1;
                    found = true;
                    break;
                }
            }
        }

        if (!found) {
            for (int i = 0; i < k - 1; i++) {
                counts[i]--;
            }
        }
    }

    // 第二遍：验证候选者
    fill(counts.begin(), counts.end(), 0);
    for (int num : nums) {
        for (int i = 0; i < k - 1; i++) {
            if (candidates[i] == num) {
                counts[i]++;
                break;
            }
        }
    }

    int n = nums.size();
    for (int i = 0; i < k - 1; i++) {
        if (counts[i] > n / k) {
            result.push_back(candidates[i]);
        }
    }

    return result;
}

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    vector<int> result = majorityElement(nums, k);
    for (int x : result) {
        cout << x << " ";
    }
    cout << '\n';

    return 0;
}
```

Python版本：
```python
def majority_element(nums, k):
    if not nums:
        return []

    # k-1个候选者
    candidates = [float('-inf')] * (k - 1)
    counts = [0] * (k - 1)

    # 第一遍：找出候选者
    for num in nums:
        found = False
        for i in range(k - 1):
            if candidates[i] == num:
                counts[i] += 1
                found = True
                break

        if not found:
            for i in range(k - 1):
                if counts[i] == 0:
                    candidates[i] = num
                    counts[i] = 1
                    found = True
                    break

        if not found:
            for i in range(k - 1):
                counts[i] -= 1

    # 第二遍：验证候选者
    counts = [0] * (k - 1)
    for num in nums:
        for i in range(k - 1):
            if candidates[i] == num:
                counts[i] += 1
                break

    n = len(nums)
    result = []
    for i in range(k - 1):
        if counts[i] > n // k:
            result.append(candidates[i])

    return result

def main():
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))

    result = majority_element(nums, k)
    print(result)

if __name__ == "__main__":
    main()
```

注意事项
--------
1. 算法只能找到一个多数元素，不能保证元素真的存在
2. 如果需要验证，需要进行第二遍遍历
3. 对于查找超过n/k的元素，需要k-1个候选者
4. 算法假设多数元素存在，如果不存在，结果无意义
5. 在实际应用中，建议进行验证

时间复杂度总结
--------------
- 基础版本：O(n) 时间，O(1) 空间
- 验证版本：O(n) 时间，O(1) 空间
- 通用版本：O(n*k) 时间，O(k) 空间

摩尔投票算法是解决多数元素问题的高效算法，其巧妙的设计使得在常数空间内完成线性时间扫描成为可能。
