Garsia-Wachs算法
=================

算法概述
--------
Garsia-Wachs算法是解决石子合并问题的高效算法。给定n堆石子，每次可以合并相邻的两堆，
花费为两堆石子数之和，求将所有石子合并成一堆的最小总花费。

朴素解法：区间DP，O(n³)时间复杂度。
优化解法：Garsia-Wachs算法，O(n log n)时间复杂度。

算法思想：
1. 从左到右扫描，找到第一个满足a[i-1] <= a[i+1]的i
2. 合并a[i-1]和a[i]，产生新的石子堆
3. 将新石子堆向左移动，直到找到合适的位置
4. 重复直到只剩一堆石子

核心思想
--------
Garsia-Wachs算法的关键在于如何高效地处理合并后的石子堆。

算法流程：
1. 创建一个双端队列或数组存储石子堆
2. 从左到右找到第一个满足a[i-1] <= a[i+1]的位置i
3. 合并a[i-1]和a[i]（注意是i-1和i，不是i和i+1）
4. 将合并后的新堆向左移动，找到第一个比它大的位置
5. 重复直到只剩一堆

关键性质：
- 合并总是发生在"峰值"位置
- 向左移动确保数组保持某种"有序性"
- 可以使用数据结构优化查找过程

基础实现：O(n²)版本
-------------------
C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 50005;

int n;
long long a[MAXN];
long long ans = 0;

// O(n²)基础实现
void garsia_wachs() {
    vector<long long> stone;

    for (int i = 1; i <= n; i++) {
        stone.push_back(a[i]);
    }

    while (stone.size() > 1) {
        int idx = -1;

        // 找到第一个满足stone[idx-1] <= stone[idx+1]的位置
        for (int i = 1; i < stone.size(); i++) {
            if (stone[i-1] <= stone[i+1]) {
                idx = i;
                break;
            }
        }

        // 如果没找到，合并最后两个
        if (idx == -1) {
            idx = stone.size() - 1;
        }

        // 合并stone[idx-1]和stone[idx]
        long long new_stone = stone[idx-1] + stone[idx];
        ans += new_stone;

        // 删除stone[idx-1]和stone[idx]
        stone.erase(stone.begin() + idx - 1, stone.begin() + idx + 1);

        // 将new_stone插入到合适的位置
        int insert_pos = idx - 1;

        while (insert_pos > 0 && stone[insert_pos - 1] < new_stone) {
            insert_pos--;
        }

        stone.insert(stone.begin() + insert_pos, new_stone);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    garsia_wachs();

    cout << ans << '\n';

    return 0;
}
```

Python版本：
```python
import sys

def garsia_wachs(n, a):
    stone = a[:]
    ans = 0

    while len(stone) > 1:
        idx = -1

        # 找到第一个满足stone[idx-1] <= stone[idx+1]的位置
        for i in range(1, len(stone)):
            if stone[i-1] <= stone[i+1]:
                idx = i
                break

        # 如果没找到，合并最后两个
        if idx == -1:
            idx = len(stone) - 1

        # 合并stone[idx-1]和stone[idx]
        new_stone = stone[idx-1] + stone[idx]
        ans += new_stone

        # 删除stone[idx-1]和stone[idx]
        del stone[idx-1:idx+1]

        # 将new_stone插入到合适的位置
        insert_pos = idx - 1

        while insert_pos > 0 and stone[insert_pos - 1] < new_stone:
            insert_pos -= 1

        stone.insert(insert_pos, new_stone)

    return ans

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    ans = garsia_wachs(n, a)
    print(ans)

solve()
```

优化实现：O(n log n)版本
------------------------
使用数据结构优化查找过程。

C++版本（使用set）：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 50005;

int n;
long long ans = 0;
list<long long> stone;
set<list<long long>::iterator> candidates;

// 检查位置it是否可以合并
bool is_valid(list<long long>::iterator it) {
    if (it == stone.begin()) return false;
    auto left = it;
    left--;

    auto right = it;
    right++;

    if (right == stone.end()) return true;

    return *left <= *right;
}

// 更新候选位置
void update_candidates(list<long long>::iterator it) {
    if (is_valid(it)) {
        candidates.insert(it);
    } else {
        candidates.erase(it);
    }
}

void garsia_wachs() {
    // 初始化
    for (int i = 1; i <= n; i++) {
        long long val;
        cin >> val;
        stone.push_back(val);
    }

    for (auto it = next(stone.begin()); it != stone.end(); it++) {
        update_candidates(it);
    }

    while (stone.size() > 1) {
        // 取第一个候选位置
        auto it = *candidates.begin();
        candidates.erase(it);

        auto left = it;
        left--;

        // 合并
        long long new_stone = *left + *it;
        ans += new_stone;

        // 删除原位置
        auto erase_left = stone.erase(left);
        auto erase_it = stone.erase(erase_left);

        // 插入新石子堆
        auto insert_pos = erase_it;
        while (insert_pos != stone.begin() && *prev(insert_pos) < new_stone) {
            insert_pos--;
        }
        insert_pos = stone.insert(insert_pos, new_stone);

        // 更新候选位置
        if (insert_pos != stone.begin()) {
            update_candidates(prev(insert_pos));
        }
        if (next(insert_pos) != stone.end()) {
            update_candidates(next(insert_pos));
        }
        update_candidates(insert_pos);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;

    garsia_wachs();

    cout << ans << '\n';

    return 0;
}
```

Python版本（使用堆）：
```python
import sys
import heapq

def garsia_wachs_optimized(n, a):
    stone = a[:]
    ans = 0

    # 使用双端队列
    from collections import deque
    dq = deque(stone)

    while len(dq) > 1:
        # 找到合并位置
        idx = -1
        for i in range(1, len(dq)):
            if i + 1 >= len(dq) or dq[i-1] <= dq[i+1]:
                idx = i
                break

        if idx == -1:
            idx = len(dq) - 1

        # 合并
        new_val = dq[idx-1] + dq[idx]
        ans += new_val

        # 删除
        del dq[idx]
        del dq[idx-1]

        # 插入
        insert_pos = idx - 1
        while insert_pos > 0 and dq[insert_pos - 1] < new_val:
            insert_pos -= 1

        dq.insert(insert_pos, new_val)

    return ans

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    ans = garsia_wachs_optimized(n, a)
    print(ans)

solve()
```

应用一：理解算法流程
--------------------
通过具体例子理解Garsia-Wachs算法的执行过程。

C++版本（带详细输出）：
```cpp
#include <bits/stdc++.h>
using namespace std;

void solve_example() {
    vector<int> a = {1, 2, 3, 4};
    long long ans = 0;
    int step = 0;

    cout << "初始石子堆: ";
    for (int x : a) cout << x << " ";
    cout << "\n\n";

    while (a.size() > 1) {
        step++;
        cout << "步骤 " << step << ":\n";

        int idx = -1;
        for (int i = 1; i < a.size(); i++) {
            if (a[i-1] <= a[i+1]) {
                idx = i;
                break;
            }
        }

        if (idx == -1) idx = a.size() - 1;

        cout << "  找到位置 " << idx << ": " << a[idx-1] << " + " << a[idx] << "\n";

        int new_val = a[idx-1] + a[idx];
        ans += new_val;

        cout << "  合并值: " << new_val << "\n";
        cout << "  当前总花费: " << ans << "\n";

        a.erase(a.begin() + idx - 1, a.begin() + idx + 1);

        int insert_pos = idx - 1;
        while (insert_pos > 0 && a[insert_pos - 1] < new_val) {
            insert_pos--;
        }

        a.insert(a.begin() + insert_pos, new_val);

        cout << "  合并后: ";
        for (int x : a) cout << x << " ";
        cout << "\n\n";
    }

    cout << "最小总花费: " << ans << "\n";
}

int main() {
    solve_example();
    return 0;
}
```

应用二：对比不同解法
--------------------
比较区间DP和Garsia-Wachs算法。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5005;

int n;
int a[MAXN];
int dp[MAXN][MAXN];
int sum[MAXN];

// 区间DP解法 O(n^3)
int interval_dp() {
    memset(dp, 0x3f, sizeof(dp));

    for (int i = 1; i <= n; i++) {
        dp[i][i] = 0;
    }

    for (int len = 2; len <= n; len++) {
        for (int i = 1; i + len - 1 <= n; i++) {
            int j = i + len - 1;

            for (int k = i; k < j; k++) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1]);
            }
        }
    }

    return dp[1][n];
}

// Garsia-Wachs解法 O(n log n)
long long garsia_wachs() {
    vector<long long> stone;

    for (int i = 1; i <= n; i++) {
        stone.push_back(a[i]);
    }

    long long ans = 0;

    while (stone.size() > 1) {
        int idx = -1;

        for (int i = 1; i < stone.size(); i++) {
            if (stone[i-1] <= stone[i+1]) {
                idx = i;
                break;
            }
        }

        if (idx == -1) idx = stone.size() - 1;

        long long new_val = stone[idx-1] + stone[idx];
        ans += new_val;

        stone.erase(stone.begin() + idx - 1, stone.begin() + idx + 1);

        int insert_pos = idx - 1;
        while (insert_pos > 0 && stone[insert_pos - 1] < new_val) {
            insert_pos--;
        }

        stone.insert(stone.begin() + insert_pos, new_val);
    }

    return ans;
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = sum[i-1] + a[i];
    }

    // 区间DP
    auto start = chrono::high_resolution_clock::now();
    int dp_ans = interval_dp();
    auto end = chrono::high_resolution_clock::now();
    auto dp_time = chrono::duration_cast<chrono::microseconds>(end - start);

    // Garsia-Wachs
    start = chrono::high_resolution_clock::now();
    long long gw_ans = garsia_wachs();
    end = chrono::high_resolution_clock::now();
    auto gw_time = chrono::duration_cast<chrono::microseconds>(end - start);

    cout << "区间DP答案: " << dp_ans << "\n";
    cout << "区间DP时间: " << dp_time.count() << " 微秒\n";
    cout << "Garsia-Wachs答案: " << gw_ans << "\n";
    cout << "Garsia-Wachs时间: " << gw_time.count() << " 微秒\n";

    return 0;
}
```

应用三：解决经典题目
--------------------
例题：石子合并（Luogu P5569）

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
long long a[MAXN];

long long garsia_wachs() {
    vector<long long> stone;

    for (int i = 1; i <= n; i++) {
        stone.push_back(a[i]);
    }

    long long ans = 0;

    while (stone.size() > 1) {
        int idx = -1;

        for (int i = 1; i < stone.size(); i++) {
            if (i + 1 >= stone.size() || stone[i-1] <= stone[i+1]) {
                idx = i;
                break;
            }
        }

        if (idx == -1) idx = stone.size() - 1;

        long long new_val = stone[idx-1] + stone[idx];
        ans += new_val;

        stone.erase(stone.begin() + idx - 1, stone.begin() + idx + 1);

        int insert_pos = idx - 1;
        while (insert_pos > 0 && stone[insert_pos - 1] < new_val) {
            insert_pos--;
        }

        stone.insert(stone.begin() + insert_pos, new_val);
    }

    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    cout << garsia_wachs() << '\n';

    return 0;
}
```

Python版本：
```python
import sys

def garsia_wachs(n, a):
    stone = a[:]
    ans = 0

    while len(stone) > 1:
        idx = -1

        for i in range(1, len(stone)):
            if i + 1 >= len(stone) or stone[i-1] <= stone[i+1]:
                idx = i
                break

        if idx == -1:
            idx = len(stone) - 1

        new_val = stone[idx-1] + stone[idx]
        ans += new_val

        del stone[idx-1:idx+1]

        insert_pos = idx - 1
        while insert_pos > 0 and stone[insert_pos - 1] < new_val:
            insert_pos -= 1

        stone.insert(insert_pos, new_val)

    return ans

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    print(garsia_wachs(n, a))

solve()
```

应用四：环形石子合并
--------------------
问题描述：n堆石子围成一个环，每次合并相邻两堆，求最小花费。

解决方法：将环展开，枚举断点。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 505;
const int INF = 0x3f3f3f3f;

int n;
int a[MAXN];
int dp[MAXN][MAXN];
int sum[MAXN];

// 区间DP解环形石子合并
int circular_interval_dp() {
    // 将数组复制一份
    for (int i = 1; i <= n; i++) {
        a[i + n] = a[i];
    }

    memset(dp, 0x3f, sizeof(dp));

    for (int i = 1; i <= 2 * n; i++) {
        sum[i] = sum[i-1] + a[i];
        dp[i][i] = 0;
    }

    for (int len = 2; len <= n; len++) {
        for (int i = 1; i + len - 1 <= 2 * n; i++) {
            int j = i + len - 1;

            for (int k = i; k < j; k++) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1]);
            }
        }
    }

    int ans = INF;
    for (int i = 1; i <= n; i++) {
        ans = min(ans, dp[i][i + n - 1]);
    }

    return ans;
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    cout << circular_interval_dp() << '\n';

    return 0;
}
```

算法正确性证明
--------------
Garsia-Wachs算法的正确性基于以下观察：

1. **最优子结构**：如果最优合并序列中第一次合并是a[i]和a[i+1]，
   那么合并后的子问题也是最优的。

2. **关键性质**：对于第一次合并的位置i，必然满足a[i-1] <= a[i+1]。
   反证：如果a[i-1] > a[i+1]，那么先合并a[i-1]和a[i]会更优。

3. **移动的正确性**：合并后的新石子堆向左移动，不会影响后续的最优性。

4. **贪心选择**：每次选择满足条件的最左位置进行合并，可以得到全局最优解。

时间复杂度分析
--------------
- O(n²)实现：每次查找位置O(n)，合并操作O(n)，总共O(n)次合并
- O(n log n)实现：使用数据结构优化查找，每次操作O(log n)
- 空间复杂度：O(n)

典型例题
--------
1. 石子合并（Luogu P5569）：Garsia-Wachs模板题
2. 环形石子合并（Luogu P1880）：环形版本，需要区间DP
3. [NOI1995]石子合并：经典题目
4. [HNOI2003]激光炸弹：类似思路
5. [Codeforces]Merge the stones：变体问题

注意事项
--------
1. Garsia-Wachs算法只适用于线性石子合并
2. 环形石子合并需要用区间DP或其他方法
3. 合并位置的选择必须满足a[i-1] <= a[i+1]的条件
4. 新石子堆的插入位置需要正确查找
5. 边界条件：当只剩两堆时，直接合并
6. 算法的关键在于高效实现"查找合并位置"和"插入新石子堆"

算法变种
--------
1. **四边形不等式优化**：某些情况下可以用四边形不等式优化DP
2. **Knuth优化**：当DP满足特定条件时，可以用Knuth优化到O(n²)
3. **平行四边形优化**：适用于特定类型的DP转移
4. **单调性优化**：利用决策的单调性优化

总结
----
Garsia-Wachs算法是一个巧妙的算法，将O(n³)的区间DP优化到O(n log n)。
它的核心思想是：
1. 识别关键合并位置
2. 高效维护石子堆序列
3. 利用数据结构优化查找

掌握Garsia-Wachs算法对理解贪心、数据结构优化等都有很大帮助。
虽然它适用范围较窄，但在石子合并类问题中是必学的算法。

与区间DP的对比：
- 区间DP：通用但慢，O(n³)
- Garsia-Wachs：特定问题快，O(n log n)
- 根据题目约束选择合适的方法
