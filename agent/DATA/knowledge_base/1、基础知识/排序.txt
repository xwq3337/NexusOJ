排序算法（Sorting Algorithms）
==============================

算法概述
--------
排序是计算机科学中最基础也是最重要的问题之一。排序算法分为比较排序和非比较排序两大类。

比较排序：通过比较元素间的大小关系进行排序，时间复杂度下界为O(n log n)
非比较排序：不通过比较，利用元素本身的特性进行排序

常见的排序算法：
- 快速排序、归并排序：O(n log n)，分治思想
- 堆排序：O(n log n)，利用堆数据结构
- 计数排序、桶排序：O(n)，非比较排序

一、快速排序（Quick Sort）
-------------------------
算法思想：分治法
1. 选择一个基准元素（pivot）
2. 将小于pivot的元素放左边，大于pivot的放右边
3. 递归处理左右两部分
4. 平均时间复杂度：O(n log n)，最坏：O(n²)

C++版本（标准实现）：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int a[MAXN];

// 快速排序分区函数
int partition(int left, int right) {
    int pivot = a[right];  // 选择最右元素作为基准
    int i = left - 1;      // i是小于基准的区域的右边界

    for (int j = left; j < right; j++) {
        if (a[j] <= pivot) {
            i++;
            swap(a[i], a[j]);
        }
    }
    swap(a[i + 1], a[right]);
    return i + 1;
}

// 快速排序主函数
void quickSort(int left, int right) {
    if (left < right) {
        int pi = partition(left, right);
        quickSort(left, pi - 1);
        quickSort(pi + 1, right);
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    quickSort(0, n - 1);

    for (int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本（标准实现）：
```python
import sys

def partition(arr, left, right):
    pivot = arr[right]
    i = left - 1

    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    return i + 1

def quickSort(arr, left, right):
    if left < right:
        pi = partition(arr, left, right)
        quickSort(arr, left, pi - 1)
        quickSort(arr, pi + 1, right)

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    quickSort(a, 0, n - 1)

    print(' '.join(map(str, a)))

solve()
```

C++版本（随机化优化）：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int a[MAXN];

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

// 随机选择基准，避免最坏情况
int partition(int left, int right) {
    int rand_idx = uniform_int_distribution<int>(left, right)(rng);
    swap(a[rand_idx], a[right]);
    int pivot = a[right];

    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (a[j] <= pivot) {
            i++;
            swap(a[i], a[j]);
        }
    }
    swap(a[i + 1], a[right]);
    return i + 1;
}

void quickSort(int left, int right) {
    if (left < right) {
        int pi = partition(left, right);
        quickSort(left, pi - 1);
        quickSort(pi + 1, right);
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    quickSort(0, n - 1);

    for (int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本（随机化优化）：
```python
import sys
import random

def partition(arr, left, right):
    rand_idx = random.randint(left, right)
    arr[rand_idx], arr[right] = arr[right], arr[rand_idx]
    pivot = arr[right]

    i = left - 1
    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    return i + 1

def quickSort(arr, left, right):
    if left < right:
        pi = partition(arr, left, right)
        quickSort(arr, left, pi - 1)
        quickSort(arr, pi + 1, right)

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    quickSort(a, 0, n - 1)

    print(' '.join(map(str, a)))

solve()
```

二、归并排序（Merge Sort）
------------------------
算法思想：分治法
1. 将数组从中间分成两半
2. 递归对左右两半排序
3. 将两个有序数组合并成一个有序数组
4. 时间复杂度：O(n log n)，稳定排序

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int a[MAXN];
int temp[MAXN];  // 临时数组用于归并

// 合并两个有序数组
void merge(int left, int mid, int right) {
    int i = left;       // 左半部分起始位置
    int j = mid + 1;    // 右半部分起始位置
    int k = left;       // 临时数组起始位置

    while (i <= mid && j <= right) {
        if (a[i] <= a[j]) {
            temp[k++] = a[i++];
        } else {
            temp[k++] = a[j++];
        }
    }

    // 处理剩余元素
    while (i <= mid) {
        temp[k++] = a[i++];
    }
    while (j <= right) {
        temp[k++] = a[j++];
    }

    // 将临时数组复制回原数组
    for (i = left; i <= right; i++) {
        a[i] = temp[i];
    }
}

// 归并排序主函数
void mergeSort(int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(left, mid);
        mergeSort(mid + 1, right);
        merge(left, mid, right);
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    mergeSort(0, n - 1);

    for (int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本：
```python
import sys

def merge(arr, left, mid, right):
    temp = []
    i, j = left, mid + 1

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp.append(arr[i])
            i += 1
        else:
            temp.append(arr[j])
            j += 1

    while i <= mid:
        temp.append(arr[i])
        i += 1
    while j <= right:
        temp.append(arr[j])
        j += 1

    arr[left:right + 1] = temp

def mergeSort(arr, left, right):
    if left < right:
        mid = left + (right - left) // 2
        mergeSort(arr, left, mid)
        mergeSort(arr, mid + 1, right)
        merge(arr, left, mid, right)

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    mergeSort(a, 0, n - 1)

    print(' '.join(map(str, a)))

solve()
```

应用示例：归并排序求逆序对
-------------------------
问题：求序列中逆序对的数量。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int a[MAXN];
int temp[MAXN];
long long inv_count = 0;  // 逆序对数量

void merge(int left, int mid, int right) {
    int i = left;
    int j = mid + 1;
    int k = left;

    while (i <= mid && j <= right) {
        if (a[i] <= a[j]) {
            temp[k++] = a[i++];
        } else {
            temp[k++] = a[j++];
            // a[i]到a[mid]都大于a[j]，形成逆序对
            inv_count += (mid - i + 1);
        }
    }

    while (i <= mid) {
        temp[k++] = a[i++];
    }
    while (j <= right) {
        temp[k++] = a[j++];
    }

    for (i = left; i <= right; i++) {
        a[i] = temp[i];
    }
}

void mergeSort(int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(left, mid);
        mergeSort(mid + 1, right);
        merge(left, mid, right);
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    mergeSort(0, n - 1);

    cout << inv_count << '\n';

    return 0;
}
```

Python版本：
```python
import sys

def merge(arr, left, mid, right):
    global inv_count
    temp = []
    i, j = left, mid + 1

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp.append(arr[i])
            i += 1
        else:
            temp.append(arr[j])
            j += 1
            inv_count += (mid - i + 1)

    while i <= mid:
        temp.append(arr[i])
        i += 1
    while j <= right:
        temp.append(arr[j])
        j += 1

    arr[left:right + 1] = temp

def mergeSort(arr, left, right):
    if left < right:
        mid = left + (right - left) // 2
        mergeSort(arr, left, mid)
        mergeSort(arr, mid + 1, right)
        merge(arr, left, mid, right)

def solve():
    global inv_count
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    inv_count = 0
    mergeSort(a, 0, n - 1)

    print(inv_count)

solve()
```

三、堆排序（Heap Sort）
---------------------
算法思想：利用堆数据结构
1. 将数组构建成最大堆
2. 不断取出堆顶元素（最大值），放到数组末尾
3. 调整堆，重复步骤2
4. 时间复杂度：O(n log n)，原地排序

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int a[MAXN];

// 堆调整（大顶堆）
void heapify(int arr[], int n, int i) {
    int largest = i;        // 初始化最大元素为根节点
    int left = 2 * i + 1;   // 左子节点
    int right = 2 * i + 2;  // 右子节点

    // 如果左子节点大于根节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // 如果右子节点大于当前最大节点
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // 如果最大元素不是根节点
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// 堆排序主函数
void heapSort(int arr[], int n) {
    // 构建最大堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // 逐个提取元素
    for (int i = n - 1; i > 0; i--) {
        // 将当前根节点（最大值）移动到末尾
        swap(arr[0], arr[i]);
        // 调整剩余元素的堆
        heapify(arr, i, 0);
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    heapSort(a, n);

    for (int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本：
```python
import sys

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapSort(arr, n):
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    heapSort(a, n)

    print(' '.join(map(str, a)))

solve()
```

四、计数排序（Counting Sort）
---------------------------
算法思想：统计每个元素出现的次数，按次数输出
1. 找出数组中的最大值和最小值
2. 统计每个元素出现的次数
3. 根据统计结果输出有序数组
4. 时间复杂度：O(n + k)，k为数据范围
5. 仅适用于整数，且数据范围不宜过大

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
const int MAXV = 100005;

int n;
int a[MAXN];
int count[MAXV];  // 计数数组
int sorted[MAXN]; // 排序后的数组

void countingSort() {
    int max_val = *max_element(a, a + n);
    int min_val = *min_element(a, a + n);
    int range = max_val - min_val + 1;

    memset(count, 0, sizeof(count));

    // 统计每个元素出现的次数
    for (int i = 0; i < n; i++) {
        count[a[i] - min_val]++;
    }

    // 计算前缀和（确定每个元素的位置）
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }

    // 从后向前遍历，保持稳定性
    for (int i = n - 1; i >= 0; i--) {
        sorted[count[a[i] - min_val] - 1] = a[i];
        count[a[i] - min_val]--;
    }

    // 复制回原数组
    for (int i = 0; i < n; i++) {
        a[i] = sorted[i];
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    countingSort();

    for (int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本：
```python
import sys

def countingSort(arr):
    if not arr:
        return arr

    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1

    count = [0] * range_val
    output = [0] * len(arr)

    # 统计每个元素出现的次数
    for num in arr:
        count[num - min_val] += 1

    # 计算前缀和
    for i in range(1, range_val):
        count[i] += count[i - 1]

    # 从后向前遍历，保持稳定性
    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1

    return output

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    sorted_a = countingSort(a)

    print(' '.join(map(str, sorted_a)))

solve()
```

五、桶排序（Bucket Sort）
-----------------------
算法思想：将元素分到不同的桶中，每个桶单独排序
1. 创建若干个桶
2. 将元素分配到对应的桶中
3. 对每个桶单独排序
4. 合并所有桶
5. 时间复杂度：O(n + k)，平均O(n)

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n;
int a[MAXN];

void bucketSort() {
    // 找出最大值和最小值
    int max_val = *max_element(a, a + n);
    int min_val = *min_element(a, a + n);

    // 确定桶的数量和范围
    int bucket_count = n;
    int bucket_range = (max_val - min_val) / bucket_count + 1;

    // 创建桶
    vector<vector<int>> buckets(bucket_count);

    // 将元素分配到桶中
    for (int i = 0; i < n; i++) {
        int bucket_idx = (a[i] - min_val) / bucket_range;
        buckets[bucket_idx].push_back(a[i]);
    }

    // 对每个桶单独排序
    for (int i = 0; i < bucket_count; i++) {
        sort(buckets[i].begin(), buckets[i].end());
    }

    // 合并所有桶
    int index = 0;
    for (int i = 0; i < bucket_count; i++) {
        for (int num : buckets[i]) {
            a[index++] = num;
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    bucketSort();

    for (int i = 0; i < n; i++) {
        cout << a[i] << " \n"[i == n - 1];
    }

    return 0;
}
```

Python版本：
```python
import sys

def bucketSort(arr):
    if not arr:
        return arr

    max_val = max(arr)
    min_val = min(val)

    # 确定桶的数量和范围
    bucket_count = len(arr)
    bucket_range = (max_val - min_val) // bucket_count + 1

    # 创建桶
    buckets = [[] for _ in range(bucket_count)]

    # 将元素分配到桶中
    for num in arr:
        bucket_idx = (num - min_val) // bucket_range
        buckets[bucket_idx].append(num)

    # 对每个桶单独排序
    for bucket in buckets:
        bucket.sort()

    # 合并所有桶
    result = []
    for bucket in buckets:
        result.extend(bucket)

    return result

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    sorted_a = bucketSort(a)

    print(' '.join(map(str, sorted_a)))

solve()
```

六、C++ STL sort使用
-------------------
C++ STL中的sort函数是基于内省排序（IntroSort）实现的，
结合了快速排序、堆排序和插入排序的优点。

C++版本（基础使用）：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    // 升序排序
    sort(a.begin(), a.end());

    for (int x : a) {
        cout << x << ' ';
    }
    cout << '\n';

    // 降序排序
    sort(a.begin(), a.end(), greater<int>());

    for (int x : a) {
        cout << x << ' ';
    }
    cout << '\n';

    return 0;
}
```

C++版本（自定义比较函数）：
```cpp
#include <bits/stdc++.h>
using namespace std;

// 自定义比较函数：按绝对值升序
bool cmp(int a, int b) {
    return abs(a) < abs(b);
}

// 结构体排序示例
struct Student {
    string name;
    int score;
    int age;
};

// 按成绩升序，成绩相同按年龄降序
bool cmpStudent(const Student& a, const Student& b) {
    if (a.score != b.score) {
        return a.score < b.score;
    }
    return a.age > b.age;
}

int main() {
    int n;
    cin >> n;

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    // 使用自定义比较函数
    sort(a.begin(), a.end(), cmp);

    for (int x : a) {
        cout << x << ' ';
    }
    cout << '\n';

    // 结构体排序
    vector<Student> students(n);
    for (int i = 0; i < n; i++) {
        cin >> students[i].name >> students[i].score >> students[i].age;
    }

    sort(students.begin(), students.end(), cmpStudent);

    for (auto& s : students) {
        cout << s.name << ' ' << s.score << ' ' << s.age << '\n';
    }

    return 0;
}
```

C++版本（Lambda表达式）：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    // 使用Lambda表达式自定义排序
    sort(a.begin(), a.end(), [](int x, int y) {
        return x % 10 < y % 10;  // 按个位数升序
    });

    for (int x : a) {
        cout << x << ' ';
    }
    cout << '\n';

    return 0;
}
```

七、Python sorted使用
--------------------
Python的sorted函数基于Timsort算法，是归并排序和插入排序的混合体。

Python版本（基础使用）：
```python
import sys

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    # 升序排序
    sorted_a = sorted(a)
    print(' '.join(map(str, sorted_a)))

    # 降序排序
    sorted_a = sorted(a, reverse=True)
    print(' '.join(map(str, sorted_a)))

    # 原地排序
    a.sort()
    print(' '.join(map(str, a)))

solve()
```

Python版本（自定义key）：
```python
import sys

def solve():
    input = sys.stdin.readline
    n = int(input())
    a = list(map(int, input().split()))

    # 按绝对值升序
    sorted_a = sorted(a, key=abs)
    print(' '.join(map(str, sorted_a)))

    # 按字符串长度排序
    words = ['apple', 'banana', 'cherry', 'date']
    sorted_words = sorted(words, key=len)
    print(' '.join(sorted_words))

    # 元组排序（多级排序）
    students = [
        ('Alice', 85, 18),
        ('Bob', 85, 19),
        ('Charlie', 90, 18)
    ]
    # 先按成绩，再按年龄
    sorted_students = sorted(students, key=lambda x: (x[1], -x[2]))
    for name, score, age in sorted_students:
        print(name, score, age)

solve()
```

Python版本（对象排序）：
```python
import sys

class Student:
    def __init__(self, name, score, age):
        self.name = name
        self.score = score
        self.age = age

    def __repr__(self):
        return f"{self.name} {self.score} {self.age}"

def solve():
    input = sys.stdin.readline
    n = int(input())

    students = []
    for _ in range(n):
        name = input().strip()
        score, age = map(int, input().split())
        students.append(Student(name, score, age))

    # 按成绩升序，成绩相同按年龄降序
    sorted_students = sorted(students, key=lambda x: (x.score, -x.age))

    for s in sorted_students:
        print(s)

solve()
```

典型例题
--------
1. 洛谷P1177：快速排序模板题
   给定n个整数，要求使用快速排序对其进行排序。

2. 洛谷P1908：逆序对
   归并排序求逆序对数量。

3. 洛谷P1093：奖学金（多级排序）
   按多级规则对学生排序。

4. 洛谷P1059：明明的随机数（去重排序）
   给定随机数序列，去重后排序输出。

5. 洛谷P1068：分数线划定（部分排序）
   找出前m名的分数线。

6. 洛谷P1923：第k小数（快速选择）
   找出第k小的数，可用快速排序思想。

注意事项
--------
1. 快速排序：
   - 平均时间复杂度O(n log n)，最坏O(n²)
   - 不稳定排序
   - 可以通过随机化pivot避免最坏情况
   - 注意处理重复元素的情况

2. 归并排序：
   - 稳定排序，时间复杂度O(n log n)
   - 需要O(n)额外空间
   - 常用于求逆序对等应用
   - Python的sorted就是基于归并排序的改进

3. 堆排序：
   - 时间复杂度O(n log n)
   - 原地排序，空间复杂度O(1)
   - 不稳定排序
   - 常用于优先队列和Top K问题

4. 计数排序：
   - 时间复杂度O(n + k)，k为数据范围
   - 稳定排序
   - 仅适用于整数，且数据范围不能太大
   - 空间复杂度取决于数据范围

5. 桶排序：
   - 平均时间复杂度O(n)
   - 适用于数据分布均匀的情况
   - 需要合理选择桶的数量和范围

6. STL sort / Python sorted：
   - 实际应用中优先使用内置排序函数
   - C++的sort基于内省排序，综合性能最优
   - Python的sorted基于Timsort，稳定且高效
   - 注意自定义比较函数的写法

时间复杂度总结
--------------
快速排序：
- 平均：O(n log n)
- 最坏：O(n²)
- 空间：O(log n)（递归栈）
- 稳定性：不稳定

归并排序：
- 时间：O(n log n)
- 空间：O(n)
- 稳定性：稳定

堆排序：
- 时间：O(n log n)
- 空间：O(1)
- 稳定性：不稳定

计数排序：
- 时间：O(n + k)
- 空间：O(k)
- 稳定性：稳定

桶排序：
- 平均：O(n)
- 最坏：O(n²)
- 空间：O(n)
- 稳定性：取决于桶内排序算法

排序算法是算法竞赛和实际编程中最常用的工具，掌握各种排序算法的原理和应用场景非常重要。
