前缀和与差分（Prefix Sum & Difference）
====================================

算法概述
--------
前缀和和差分是两种互补的算法技巧，主要用于高效处理区间的查询和修改操作。

前缀和：预处理O(n)，查询O(1)，适用于静态数组的区间查询
差分：预处理O(n)，修改O(1)，适用于区间的批量修改

核心思想
--------
1. 前缀和：通过预处理前i个元素的和，将区间求和转化为两个前缀和的差
2. 差分：维护相邻元素的差值，将区间修改转化为两个端点的修改
3. 二维前缀和/差分：将一维思想扩展到二维矩阵

一、一维前缀和
--------------
定义：prefix[i] = a[1] + a[2] + ... + a[i]
查询：sum[l, r] = prefix[r] - prefix[l-1]

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n, q;
int a[MAXN];
long long prefix[MAXN];  // 使用long long防止溢出

int main() {
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    // 预处理前缀和
    prefix[0] = 0;
    for (int i = 1; i <= n; i++) {
        prefix[i] = prefix[i-1] + a[i];
    }

    // 回答询问
    while (q--) {
        int l, r;
        cin >> l >> r;
        cout << prefix[r] - prefix[l-1] << '\n';
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    n, q = map(int, input().split())
    a = [0] + list(map(int, input().split()))

    # 预处理前缀和
    prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix[i] = prefix[i-1] + a[i]

    # 回答询问
    for _ in range(q):
        l, r = map(int, input().split())
        print(prefix[r] - prefix[l-1])

solve()
```

应用示例1：区间元素出现次数统计
-----------------------------
问题：给定一个数组，多次询问某个区间内某个值出现的次数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
const int MAXV = 10005;

int n, q;
int a[MAXN];
vector<int> pos[MAXV];  // pos[v]: 值v出现的所有位置

int main() {
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        pos[a[i]].push_back(i);
    }

    while (q--) {
        int l, r, x;
        cin >> l >> r >> x;

        // 二分查找区间[l, r]内x出现的次数
        auto left = lower_bound(pos[x].begin(), pos[x].end(), l);
        auto right = upper_bound(pos[x].begin(), pos[x].end(), r);
        cout << right - left << '\n';
    }

    return 0;
}
```

Python版本：
```python
import sys
from bisect import bisect_left, bisect_right

def solve():
    input = sys.stdin.readline
    n, q = map(int, input().split())
    a = [0] + list(map(int, input().split()))

    from collections import defaultdict
    pos = defaultdict(list)

    for i in range(1, n + 1):
        pos[a[i]].append(i)

    for _ in range(q):
        l, r, x = map(int, input().split())
        if x not in pos:
            print(0)
        else:
            left = bisect_left(pos[x], l)
            right = bisect_right(pos[x], r)
            print(right - left)

solve()
```

应用示例2：前缀和的差分
---------------------
问题：求有多少个区间的和等于k。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200005;

int n, k;
int a[MAXN];
long long prefix[MAXN];
map<long long, int> cnt;

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    // 预处理前缀和
    prefix[0] = 0;
    for (int i = 1; i <= n; i++) {
        prefix[i] = prefix[i-1] + a[i];
    }

    // 统计答案
    cnt[0] = 1;  // prefix[0] = 0
    long long ans = 0;
    for (int i = 1; i <= n; i++) {
        ans += cnt[prefix[i] - k];
        cnt[prefix[i]]++;
    }

    cout << ans << '\n';

    return 0;
}
```

Python版本：
```python
import sys
from collections import defaultdict

def solve():
    input = sys.stdin.readline
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    # 预处理前缀和
    prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix[i] = prefix[i-1] + a[i]

    # 统计答案
    cnt = defaultdict(int)
    cnt[0] = 1  # prefix[0] = 0
    ans = 0
    for i in range(1, n + 1):
        ans += cnt[prefix[i] - k]
        cnt[prefix[i]] += 1

    print(ans)

solve()
```

二、二维前缀和
--------------
定义：prefix[i][j] = 矩阵(1,1)到(i,j)的矩形和
查询：矩形(x1,y1)到(x2,y2)的和 =
      prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1]

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;

int n, m, q;
int a[MAXN][MAXN];
long long prefix[MAXN][MAXN];

int main() {
    cin >> n >> m >> q;

    // 读取矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }

    // 预处理二维前缀和
    memset(prefix, 0, sizeof(prefix));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            prefix[i][j] = a[i][j]
                         + prefix[i-1][j]
                         + prefix[i][j-1]
                         - prefix[i-1][j-1];
        }
    }

    // 回答询问
    while (q--) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;

        long long ans = prefix[x2][y2]
                      - prefix[x1-1][y2]
                      - prefix[x2][y1-1]
                      + prefix[x1-1][y1-1];
        cout << ans << '\n';
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    n, m, q = map(int, input().split())

    a = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        row = list(map(int, input().split()))
        for j in range(1, m + 1):
            a[i][j] = row[j-1]

    # 预处理二维前缀和
    prefix = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            prefix[i][j] = (a[i][j]
                          + prefix[i-1][j]
                          + prefix[i][j-1]
                          - prefix[i-1][j-1])

    # 回答询问
    for _ in range(q):
        x1, y1, x2, y2 = map(int, input().split())
        ans = (prefix[x2][y2]
               - prefix[x1-1][y2]
               - prefix[x2][y1-1]
               + prefix[x1-1][y1-1])
        print(ans)

solve()
```

应用示例3：最大子矩阵和
----------------------
问题：求矩阵中元素和最大的子矩阵。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;

int n, m;
int a[MAXN][MAXN];
int row_sum[MAXN];  // 压缩后的行和

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }

    int max_sum = INT_MIN;

    // 枚举上下边界
    for (int top = 1; top <= n; top++) {
        memset(row_sum, 0, sizeof(row_sum));
        for (int bottom = top; bottom <= n; bottom++) {
            // 计算每列在[top, bottom]区间的和
            for (int col = 1; col <= m; col++) {
                row_sum[col] += a[bottom][col];
            }

            // 在row_sum上求最大子段和（一维问题）
            int current_sum = 0;
            for (int col = 1; col <= m; col++) {
                current_sum = max(row_sum[col], current_sum + row_sum[col]);
                max_sum = max(max_sum, current_sum);
            }
        }
    }

    cout << max_sum << '\n';

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    n, m = map(int, input().split())

    a = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        row = list(map(int, input().split()))
        for j in range(1, m + 1):
            a[i][j] = row[j-1]

    max_sum = float('-inf')

    # 枚举上下边界
    for top in range(1, n + 1):
        row_sum = [0] * (m + 1)
        for bottom in range(top, n + 1):
            # 计算每列在[top, bottom]区间的和
            for col in range(1, m + 1):
                row_sum[col] += a[bottom][col]

            # 在row_sum上求最大子段和
            current_sum = 0
            for col in range(1, m + 1):
                current_sum = max(row_sum[col], current_sum + row_sum[col])
                max_sum = max(max_sum, current_sum)

    print(max_sum)

solve()
```

三、一维差分
----------
定义：diff[i] = a[i] - a[i-1]
性质：a[i] = diff[1] + diff[2] + ... + diff[i]

核心操作：
- 区间[l, r]每个元素加x：diff[l] += x, diff[r+1] -= x
- 最后通过前缀和还原原数组

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n, m;
int a[MAXN];
int diff[MAXN];

int main() {
    cin >> n >> m;

    // 读取原数组
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    // 构建差分数组
    diff[1] = a[1];
    for (int i = 2; i <= n; i++) {
        diff[i] = a[i] - a[i-1];
    }

    // 处理区间修改
    while (m--) {
        int l, r, x;
        cin >> l >> r >> x;
        diff[l] += x;
        diff[r+1] -= x;
    }

    // 还原数组并输出
    for (int i = 1; i <= n; i++) {
        if (i > 1) diff[i] += diff[i-1];
        cout << diff[i] << " \n"[i == n];
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    n, m = map(int, input().split())
    a = list(map(int, input().split()))

    # 构建差分数组
    diff = [0] * (n + 2)
    diff[1] = a[0]
    for i in range(2, n + 1):
        diff[i] = a[i-1] - a[i-2]

    # 处理区间修改
    for _ in range(m):
        l, r, x = map(int, input().split())
        diff[l] += x
        diff[r + 1] -= x

    # 还原数组并输出
    for i in range(1, n + 1):
        if i > 1:
            diff[i] += diff[i-1]
        print(diff[i], end=' ' if i < n else '\n')

solve()
```

应用示例4：差分与前缀和的结合
---------------------------
问题：有一个初始全为0的数组，进行m次区间加操作，求最终数组。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

int n, m;
int diff[MAXN];

int main() {
    cin >> n >> m;

    memset(diff, 0, sizeof(diff));

    // 处理区间修改
    while (m--) {
        int l, r, x;
        cin >> l >> r >> x;
        diff[l] += x;
        if (r + 1 <= n) diff[r+1] -= x;
    }

    // 还原数组
    for (int i = 1; i <= n; i++) {
        if (i > 1) diff[i] += diff[i-1];
        cout << diff[i] << " \n"[i == n];
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    n, m = map(int, input().split())

    diff = [0] * (n + 2)

    # 处理区间修改
    for _ in range(m):
        l, r, x = map(int, input().split())
        diff[l] += x
        if r + 1 <= n:
            diff[r + 1] -= x

    # 还原数组
    for i in range(1, n + 1):
        if i > 1:
            diff[i] += diff[i-1]
        print(diff[i], end=' ' if i < n else '\n')

solve()
```

四、二维差分
----------
定义：diff[i][j] 表示a[i][j]与相邻元素的差分关系

核心操作：
- 矩形(x1,y1)到(x2,y2)每个元素加x：
  diff[x1][y1] += x
  diff[x2+1][y1] -= x
  diff[x1][y2+1] -= x
  diff[x2+1][y2+1] += x

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;

int n, m, q;
int a[MAXN][MAXN];
int diff[MAXN][MAXN];

int main() {
    cin >> n >> m >> q;

    // 读取原矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }

    // 构建二维差分数组
    memset(diff, 0, sizeof(diff));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] = a[i][j]
                       - a[i-1][j]
                       - a[i][j-1]
                       + a[i-1][j-1];
        }
    }

    // 处理矩形修改
    while (q--) {
        int x1, y1, x2, y2, x;
        cin >> x1 >> y1 >> x2 >> y2 >> x;

        diff[x1][y1] += x;
        diff[x2+1][y1] -= x;
        diff[x1][y2+1] -= x;
        diff[x2+1][y2+1] += x;
    }

    // 还原矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1];
            cout << diff[i][j] << " \n"[j == m];
        }
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    n, m, q = map(int, input().split())

    a = [[0] * (m + 2) for _ in range(n + 2)]
    for i in range(1, n + 1):
        row = list(map(int, input().split()))
        for j in range(1, m + 1):
            a[i][j] = row[j-1]

    # 构建二维差分数组
    diff = [[0] * (m + 2) for _ in range(n + 2)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            diff[i][j] = (a[i][j]
                         - a[i-1][j]
                         - a[i][j-1]
                         + a[i-1][j-1])

    # 处理矩形修改
    for _ in range(q):
        x1, y1, x2, y2, x = map(int, input().split())
        diff[x1][y1] += x
        diff[x2+1][y1] -= x
        diff[x1][y2+1] -= x
        diff[x2+1][y2+1] += x

    # 还原矩阵
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            diff[i][j] += (diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1])
            print(diff[i][j], end=' ' if j < m else '\n')

solve()
```

典型例题
--------
1. 洛谷P3397：地毯（二维差分模板题）
   给定n×n矩阵，进行m次矩形区域加操作，输出最终矩阵。

2. 洛谷P1719：最大加权矩形（二维前缀和）
   给定矩阵，求元素和最大的子矩阵。

3. 洛谷P1387：最大正方形
   给定01矩阵，求最大的全1正方形。

4. 洛谷P2004：领地选择
   给定矩阵，求价值最大的子矩阵及其位置。

5. 洛谷P1115：最大子段和
   给定序列，求和最大的连续子序列。

6. 洛谷P2367：语文成绩（一维差分）
   给定初始数组，进行区间加操作，求最终数组。

注意事项
--------
1. 前缀和数组要注意下标从1开始，避免边界问题
2. 前缀和可能溢出，建议使用long long
3. 差分数组的大小要比原数组大1，处理r+1时避免越界
4. 二维前缀和的查询公式要小心，注意加减的顺序
5. 二维差分的修改操作涉及四个位置，容易遗漏
6. 前缀和适用于多次查询、少量修改的场景
7. 差分适用于多次修改、最终查询的场景
8. 可以结合使用：先用差分处理修改，再用前缀和查询

时间复杂度总结
--------------
一维前缀和：
- 预处理：O(n)
- 查询：O(1)
- 空间：O(n)

二维前缀和：
- 预处理：O(n×m)
- 查询：O(1)
- 空间：O(n×m)

一维差分：
- 预处理：O(n)
- 修改：O(1)
- 还原：O(n)
- 空间：O(n)

二维差分：
- 预处理：O(n×m)
- 修改：O(1)
- 还原：O(n×m)
- 空间：O(n×m)

前缀和与差分是算法竞赛中最基础的技巧之一，掌握好它们对于处理区间问题至关重要。
