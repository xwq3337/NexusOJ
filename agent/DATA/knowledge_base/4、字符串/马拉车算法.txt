马拉车算法（Manacher's Algorithm）
================================

算法概述
--------
马拉车算法是一种用于在线性时间内求解最长回文子串的算法。它通过利用已知的回文信息，避免重复计算，将时间复杂度从朴素算法的O(n²)优化到O(n)。

核心思想
--------
1. 在字符间插入特殊字符（如'#'），将奇偶长度回文统一处理
2. 维护右边界最远的回文串，利用对称性快速计算新的回文半径
3. 使用三个关键变量：
   - p[i]：以位置i为中心的最长回文半径
   - mx：当前找到的回文串的最右边界
   - center：对应mx的回文中心

算法原理
--------
1. 字符串预处理：在相邻字符间插入特殊字符，统一奇偶回文
   - 原串："abba"
   - 处理后："^#a#b#b#a#$"（添加起始和结束标记）

2. 关键性质：
   - 当i < mx时，p[i] >= min(p[2*center-i], mx-i)
   - 如果i关于center的对称点j的回文完全在[center-mx, center+mx]内，则p[i] = p[j]
   - 否则p[i]至少能扩展到mx，然后再尝试扩展

3. 算法流程：
   - 遍历每个位置i
   - 利用对称性初始化p[i]
   - 尝试向两边扩展
   - 更新mx和center

基础模板
--------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 11000005;

char s[MAXN];      // 原始字符串
char str[MAXN];    // 处理后的字符串
int p[MAXN];       // p[i]: 以位置i为中心的最长回文半径

// 预处理字符串
void init() {
    int n = strlen(s);
    str[0] = '^';  // 起始标记
    str[1] = '#';
    int j = 2;
    for (int i = 0; i < n; i++) {
        str[j++] = s[i];
        str[j++] = '#';
    }
    str[j] = '$';  // 结束标记
    str[j + 1] = '\0';
}

// 马拉车算法
void manacher() {
    int n = strlen(str);
    int mx = 0, center = 0;

    for (int i = 1; i < n; i++) {
        // 利用对称性初始化
        if (i < mx) {
            p[i] = min(p[2 * center - i], mx - i);
        } else {
            p[i] = 1;
        }

        // 尝试扩展
        while (str[i + p[i]] == str[i - p[i]]) {
            p[i]++;
        }

        // 更新mx和center
        if (i + p[i] > mx) {
            mx = i + p[i];
            center = i;
        }
    }
}

int main() {
    scanf("%s", s);
    init();
    manacher();

    int n = strlen(str);
    int max_len = 0;
    int pos = 0;

    for (int i = 1; i < n; i++) {
        if (p[i] > max_len) {
            max_len = p[i];
            pos = i;
        }
    }

    // 原始字符串中的回文串长度 = p[pos] - 1
    printf("Longest palindrome length: %d\n", max_len - 1);

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    s = input().strip()

    # 预处理字符串
    str_arr = ['^']
    for ch in s:
        str_arr.append('#')
        str_arr.append(ch)
    str_arr.append('#')
    str_arr.append('$')

    n = len(str_arr)
    p = [0] * n
    mx = 0
    center = 0

    for i in range(1, n - 1):
        # 利用对称性初始化
        if i < mx:
            p[i] = min(p[2 * center - i], mx - i)
        else:
            p[i] = 1

        # 尝试扩展
        while str_arr[i + p[i]] == str_arr[i - p[i]]:
            p[i] += 1

        # 更新mx和center
        if i + p[i] > mx:
            mx = i + p[i]
            center = i

    max_len = max(p)
    pos = p.index(max_len)

    print(f"Longest palindrome length: {max_len - 1}")

solve()
```

应用一：求最长回文子串
--------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 11000005;

char s[MAXN], str[MAXN];
int p[MAXN];

void init() {
    int n = strlen(s);
    str[0] = '^';
    str[1] = '#';
    int j = 2;
    for (int i = 0; i < n; i++) {
        str[j++] = s[i];
        str[j++] = '#';
    }
    str[j] = '$';
    str[j + 1] = '\0';
}

void manacher() {
    int n = strlen(str);
    int mx = 0, center = 0;

    for (int i = 1; i < n; i++) {
        if (i < mx) {
            p[i] = min(p[2 * center - i], mx - i);
        } else {
            p[i] = 1;
        }

        while (str[i + p[i]] == str[i - p[i]]) {
            p[i]++;
        }

        if (i + p[i] > mx) {
            mx = i + p[i];
            center = i;
        }
    }
}

int main() {
    scanf("%s", s);
    init();
    manacher();

    int n = strlen(str);
    int max_len = 0, pos = 0;

    for (int i = 1; i < n; i++) {
        if (p[i] > max_len) {
            max_len = p[i];
            pos = i;
        }
    }

    printf("Length: %d\n", max_len - 1);

    // 提取最长回文子串
    int start = (pos - max_len + 1) / 2;
    printf("Palindrome: ");
    for (int i = start; i < start + max_len - 1; i++) {
        printf("%c", s[i]);
    }
    printf("\n");

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    s = input().strip()

    # 预处理
    str_arr = ['^']
    for ch in s:
        str_arr.append('#')
        str_arr.append(ch)
    str_arr.append('#')
    str_arr.append('$')

    n = len(str_arr)
    p = [0] * n
    mx = center = 0

    for i in range(1, n - 1):
        if i < mx:
            p[i] = min(p[2 * center - i], mx - i)
        else:
            p[i] = 1

        while str_arr[i + p[i]] == str_arr[i - p[i]]:
            p[i] += 1

        if i + p[i] > mx:
            mx = i + p[i]
            center = i

    max_len = max(p)
    pos = p.index(max_len)

    print(f"Length: {max_len - 1}")

    # 提取最长回文子串
    start = (pos - max_len + 1) // 2
    print(f"Palindrome: {s[start:start + max_len - 1]}")

solve()
```

应用二：统计回文串数量
--------------------
统计字符串中所有回文子串的数量。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 11000005;

char s[MAXN], str[MAXN];
int p[MAXN];
long long cnt = 0;  // 回文串计数

void init() {
    int n = strlen(s);
    str[0] = '^';
    str[1] = '#';
    int j = 2;
    for (int i = 0; i < n; i++) {
        str[j++] = s[i];
        str[j++] = '#';
    }
    str[j] = '$';
    str[j + 1] = '\0';
}

void manacher() {
    int n = strlen(str);
    int mx = 0, center = 0;
    cnt = 0;

    for (int i = 1; i < n; i++) {
        if (i < mx) {
            p[i] = min(p[2 * center - i], mx - i);
        } else {
            p[i] = 1;
        }

        while (str[i + p[i]] == str[i - p[i]]) {
            p[i]++;
        }

        if (i + p[i] > mx) {
            mx = i + p[i];
            center = i;
        }

        // 统计以i为中心的回文串数量
        // 回文半径为p[i]，意味着有p[i]-1个回文串
        cnt += p[i] / 2;  // 除以2是因为#的存在
    }
}

int main() {
    scanf("%s", s);
    init();
    manacher();

    printf("Total palindromes: %lld\n", cnt);

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    s = input().strip()

    # 预处理
    str_arr = ['^']
    for ch in s:
        str_arr.append('#')
        str_arr.append(ch)
    str_arr.append('#')
    str_arr.append('$')

    n = len(str_arr)
    p = [0] * n
    mx = center = 0
    cnt = 0

    for i in range(1, n - 1):
        if i < mx:
            p[i] = min(p[2 * center - i], mx - i)
        else:
            p[i] = 1

        while str_arr[i + p[i]] == str_arr[i - p[i]]:
            p[i] += 1

        if i + p[i] > mx:
            mx = i + p[i]
            center = i

        cnt += p[i] // 2

    print(f"Total palindromes: {cnt}")

solve()
```

应用三：回文串判定与查询
----------------------
快速判断某个子串是否是回文串。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 11000005;

char s[MAXN], str[MAXN];
int p[MAXN];

void init() {
    int n = strlen(s);
    str[0] = '^';
    str[1] = '#';
    int j = 2;
    for (int i = 0; i < n; i++) {
        str[j++] = s[i];
        str[j++] = '#';
    }
    str[j] = '$';
    str[j + 1] = '\0';
}

void manacher() {
    int n = strlen(str);
    int mx = 0, center = 0;

    for (int i = 1; i < n; i++) {
        if (i < mx) {
            p[i] = min(p[2 * center - i], mx - i);
        } else {
            p[i] = 1;
        }

        while (str[i + p[i]] == str[i - p[i]]) {
            p[i]++;
        }

        if (i + p[i] > mx) {
            mx = i + p[i];
            center = i;
        }
    }
}

// 查询[l, r]子串是否是回文串（0-indexed）
bool is_palindrome(int l, int r) {
    // 转换到处理后字符串的位置
    int pos = l + r + 2;  // 中心位置
    int radius = r - l + 1;  // 回文半径
    return p[pos] >= radius + 1;
}

int main() {
    scanf("%s", s);
    init();
    manacher();

    int q;
    scanf("%d", &q);

    while (q--) {
        int l, r;
        scanf("%d%d", &l, &r);
        if (is_palindrome(l, r)) {
            printf("Yes\n");
        } else {
            printf("No\n");
        }
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    s = input().strip()

    # 预处理
    str_arr = ['^']
    for ch in s:
        str_arr.append('#')
        str_arr.append(ch)
    str_arr.append('#')
    str_arr.append('$')

    n = len(str_arr)
    p = [0] * n
    mx = center = 0

    for i in range(1, n - 1):
        if i < mx:
            p[i] = min(p[2 * center - i], mx - i)
        else:
            p[i] = 1

        while str_arr[i + p[i]] == str_arr[i - p[i]]:
            p[i] += 1

        if i + p[i] > mx:
            mx = i + p[i]
            center = i

    def is_palindrome(l, r):
        pos = l + r + 2
        radius = r - l + 1
        return p[pos] >= radius + 1

    q = int(input())
    for _ in range(q):
        l, r = map(int, input().split())
        print("Yes" if is_palindrome(l, r) else "No")

solve()
```

应用四：回文子串出现次数统计
--------------------------
统计每个回文子串出现的次数。

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 11000005;

char s[MAXN], str[MAXN];
int p[MAXN];
int cnt[MAXN];  // 每个位置的回文覆盖次数

void init() {
    int n = strlen(s);
    str[0] = '^';
    str[1] = '#';
    int j = 2;
    for (int i = 0; i < n; i++) {
        str[j++] = s[i];
        str[j++] = '#';
    }
    str[j] = '$';
    str[j + 1] = '\0';
}

void manacher() {
    int n = strlen(str);
    int mx = 0, center = 0;

    for (int i = 1; i < n; i++) {
        if (i < mx) {
            p[i] = min(p[2 * center - i], mx - i);
        } else {
            p[i] = 1;
        }

        while (str[i + p[i]] == str[i - p[i]]) {
            p[i]++;
        }

        if (i + p[i] > mx) {
            mx = i + p[i];
            center = i;
        }
    }
}

// 统计差分数组
void count_occurrences(int n) {
    memset(cnt, 0, sizeof(cnt));

    for (int i = 1; i < n; i++) {
        int l = i - p[i] + 1;
        int r = i + p[i] - 1;
        cnt[l]++;
        cnt[r + 1]--;
    }

    for (int i = 1; i < n; i++) {
        cnt[i] += cnt[i - 1];
    }
}

int main() {
    scanf("%s", s);
    init();
    int n = strlen(str);
    manacher();
    count_occurrences(n);

    // 输出每个位置的回文覆盖次数
    for (int i = 1; i < n; i++) {
        if (str[i] != '#') {
            printf("%c: %d\n", str[i], cnt[i]);
        }
    }

    return 0;
}
```

Python版本：
```python
import sys

def solve():
    input = sys.stdin.readline
    s = input().strip()

    # 预处理
    str_arr = ['^']
    for ch in s:
        str_arr.append('#')
        str_arr.append(ch)
    str_arr.append('#')
    str_arr.append('$')

    n = len(str_arr)
    p = [0] * n
    mx = center = 0

    for i in range(1, n - 1):
        if i < mx:
            p[i] = min(p[2 * center - i], mx - i)
        else:
            p[i] = 1

        while str_arr[i + p[i]] == str_arr[i - p[i]]:
            p[i] += 1

        if i + p[i] > mx:
            mx = i + p[i]
            center = i

    # 差分数组统计
    cnt = [0] * (n + 1)
    for i in range(1, n):
        l = i - p[i] + 1
        r = i + p[i] - 1
        cnt[l] += 1
        if r + 1 < n:
            cnt[r + 1] -= 1

    for i in range(1, n):
        cnt[i] += cnt[i - 1]

    # 输出结果
    for i in range(1, n):
        if str_arr[i] != '#':
            print(f"{str_arr[i]}: {cnt[i]}")

solve()
```

典型例题
--------
1. 最长回文子串（洛谷P3805）：基础模板题
2. 回文串计数（洛谷P5496）：统计所有回文子串
3. 回文子串查询（洛谷P4555）：判断子串是否为回文
4. 最长双回文串（洛谷P3649）：求两个不相交回文串的最大长度和
5. 回文串分割（POJ 3974）：将字符串分割成最少的回文串

注意事项
--------
1. 字符串预处理：
   - 必须在字符间插入特殊字符'#'
   - 添加起始标记'^'和结束标记'$'防止越界
   - 处理后的字符串长度约为原串的2倍

2. p数组的含义：
   - p[i]表示位置i的回文半径（包含中心）
   - 原串中的回文长度 = p[i] - 1
   - 回文串在原串中的起始位置 = (i - p[i] + 1) / 2

3. 边界处理：
   - 循环从1到n-1（不包括'^'和'$'）
   - 检查str[i+p[i]]和str[i-p[i]]时要确保不越界
   - 起始和结束字符'^'和'$'确保不会相等

4. 时间复杂度：
   - 虽然有while循环，但mx单调递增
   - 每次循环mx至少增加1，最多增加n次
   - 因此总时间复杂度为O(n)

5. 空间复杂度：
   - 需要O(n)的额外空间
   - str数组和p数组都是O(n)

时间复杂度总结
--------------
- 预处理：O(n)
- 马拉车算法：O(n)
- 单次查询：O(1)
- 空间复杂度：O(n)

马拉车算法是求解回文串问题的最优算法，理解对称性利用和边界处理是掌握该算法的关键。
