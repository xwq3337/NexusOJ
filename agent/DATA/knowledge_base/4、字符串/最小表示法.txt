最小表示法（Minimum Representation）
===================================

算法概述
--------
最小表示法用于找到字符串的最小循环表示。对于一个循环字符串（可以首尾相接的字符串），它的循环移位有n种（n为字符串长度），最小表示法能在线性时间内找到字典序最小的那个循环移位。

核心思想
--------
1. 将字符串复制一份接在末尾，得到长度为2n的字符串
2. 使用双指针i和j，分别从位置0和1开始
3. 比较以i和j开始的长度为n的子串
4. 根据比较结果移动指针，跳过不可能成为最小表示的位置
5. 当指针距离>=n时，较小的位置就是最小表示的起始位置

算法原理
--------
1. 问题定义：
   - 给定字符串S，求其所有循环移位中字典序最小的那个
   - 循环移位：S[i..n-1] + S[0..i-1]，其中0 <= i < n

2. 关键优化：
   - 如果S[i+k] == S[j+k]，继续比较
   - 如果S[i+k] < S[j+k]，则[j, j+k]都不是最小表示，j跳到j+k+1
   - 如果S[i+k] > S[j+k]，则[i, i+k]都不是最小表示，i跳到i+k+1
   - 保证i != j，如果相同则调整

3. 时间复杂度：
   - 虽然有while循环，但每次移动至少跳过k个位置
   - 总时间复杂度为O(n)

基础模板
--------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

char s[MAXN];

// 最小表示法
int minimum_representation(int n) {
    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        if (s[i + k] == s[j + k]) {
            k++;
            continue;
        }

        if (s[i + k] > s[j + k]) {
            // i开始的不是最小表示
            i = i + k + 1;
            if (i <= j) {
                i = j + 1;
            }
        } else {
            // j开始的不是最小表示
            j = j + k + 1;
            if (j <= i) {
                j = i + 1;
            }
        }

        k = 0;
    }

    return min(i, j);
}

int main() {
    scanf("%s", s);
    int n = strlen(s);

    // 将字符串复制一份接在后面
    for (int i = 0; i < n; i++) {
        s[n + i] = s[i];
    }
    s[2 * n] = '\0';

    int start = minimum_representation(n);

    printf("Minimum representation starts at: %d\n", start);
    printf("Minimum representation: ");
    for (int i = 0; i < n; i++) {
        printf("%c", s[start + i]);
    }
    printf("\n");

    return 0;
}
```

Python版本：
```python
def minimum_representation(s):
    """求字符串的最小表示"""
    n = len(s)

    # 将字符串复制一份接在后面
    s = s + s

    i, j, k = 0, 1, 0

    while i < n and j < n and k < n:
        if s[i + k] == s[j + k]:
            k += 1
            continue

        if s[i + k] > s[j + k]:
            i = i + k + 1
            if i <= j:
                i = j + 1
        else:
            j = j + k + 1
            if j <= i:
                j = i + 1

        k = 0

    start = min(i, j)
    return start, s[start:start + n]

def solve():
    s = input().strip()
    start, result = minimum_representation(s)

    print(f"Minimum representation starts at: {start}")
    print(f"Minimum representation: {result}")

solve()
```

应用一：判断两个字符串是否循环同构
--------------------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

char s1[MAXN], s2[MAXN];

int minimum_representation(char *s, int n) {
    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        if (s[i + k] == s[j + k]) {
            k++;
            continue;
        }

        if (s[i + k] > s[j + k]) {
            i = i + k + 1;
            if (i <= j) {
                i = j + 1;
            }
        } else {
            j = j + k + 1;
            if (j <= i) {
                j = i + 1;
            }
        }

        k = 0;
    }

    return min(i, j);
}

// 判断两个字符串是否循环同构
bool is_circular_isomorphic() {
    int n = strlen(s1);
    if (n != (int)strlen(s2)) {
        return false;
    }

    // 复制字符串
    for (int i = 0; i < n; i++) {
        s1[n + i] = s1[i];
        s2[n + i] = s2[i];
    }
    s1[2 * n] = s2[2 * n] = '\0';

    int start1 = minimum_representation(s1, n);
    int start2 = minimum_representation(s2, n);

    // 比较最小表示
    for (int i = 0; i < n; i++) {
        if (s1[start1 + i] != s2[start2 + i]) {
            return false;
        }
    }

    return true;
}

int main() {
    scanf("%s%s", s1, s2);

    if (is_circular_isomorphic()) {
        printf("Yes, they are circular isomorphic\n");
    } else {
        printf("No, they are not circular isomorphic\n");
    }

    return 0;
}
```

Python版本：
```python
def minimum_representation(s):
    """求字符串的最小表示"""
    n = len(s)
    s = s + s

    i, j, k = 0, 1, 0

    while i < n and j < n and k < n:
        if s[i + k] == s[j + k]:
            k += 1
            continue

        if s[i + k] > s[j + k]:
            i = i + k + 1
            if i <= j:
                i = j + 1
        else:
            j = j + k + 1
            if j <= i:
                j = i + 1

        k = 0

    return min(i, j)

def is_circular_isomorphic(s1, s2):
    """判断两个字符串是否循环同构"""
    if len(s1) != len(s2):
        return False

    start1 = minimum_representation(s1)
    start2 = minimum_representation(s2)

    # 比较最小表示
    n = len(s1)
    min1 = s1[start1:start1 + n]
    min2 = s2[start2:start2 + n]

    return min1 == min2

def solve():
    s1 = input().strip()
    s2 = input().strip()

    if is_circular_isomorphic(s1, s2):
        print("Yes, they are circular isomorphic")
    else:
        print("No, they are not circular isomorphic")

solve()
```

应用二：字符串的循环移位排序
---------------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

char s[MAXN];

int minimum_representation(char *s, int n) {
    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        if (s[i + k] == s[j + k]) {
            k++;
            continue;
        }

        if (s[i + k] > s[j + k]) {
            i = i + k + 1;
            if (i <= j) {
                i = j + 1;
            }
        } else {
            j = j + k + 1;
            if (j <= i) {
                j = i + 1;
            }
        }

        k = 0;
    }

    return min(i, j);
}

int main() {
    int n;
    scanf("%d", &n);

    vector<string> strings;

    for (int i = 0; i < n; i++) {
        scanf("%s", s);
        int len = strlen(s);

        for (int j = 0; j < len; j++) {
            s[len + j] = s[j];
        }
        s[2 * len] = '\0';

        int start = minimum_representation(s, len);

        string min_rep;
        for (int j = 0; j < len; j++) {
            min_rep += s[start + j];
        }

        strings.push_back(min_rep);
    }

    // 排序
    sort(strings.begin(), strings.end());

    printf("Sorted minimum representations:\n");
    for (const string &str : strings) {
        printf("%s\n", str.c_str());
    }

    return 0;
}
```

Python版本：
```python
def minimum_representation(s):
    """求字符串的最小表示"""
    n = len(s)
    s = s + s

    i, j, k = 0, 1, 0

    while i < n and j < n and k < n:
        if s[i + k] == s[j + k]:
            k += 1
            continue

        if s[i + k] > s[j + k]:
            i = i + k + 1
            if i <= j:
                i = j + 1
        else:
            j = j + k + 1
            if j <= i:
                j = i + 1

        k = 0

    start = min(i, j)
    return s[start:start + n]

def solve():
    n = int(input())
    strings = []

    for _ in range(n):
        s = input().strip()
        min_rep = minimum_representation(s)
        strings.append(min_rep)

    # 排序
    strings.sort()

    print("Sorted minimum representations:")
    for s in strings:
        print(s)

solve()
```

应用三：最大表示法
----------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

char s[MAXN];

// 最大表示法
int maximum_representation(int n) {
    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        if (s[i + k] == s[j + k]) {
            k++;
            continue;
        }

        if (s[i + k] < s[j + k]) {
            // i开始的不是最大表示
            i = i + k + 1;
            if (i <= j) {
                i = j + 1;
            }
        } else {
            // j开始的不是最大表示
            j = j + k + 1;
            if (j <= i) {
                j = i + 1;
            }
        }

        k = 0;
    }

    return min(i, j);
}

int main() {
    scanf("%s", s);
    int n = strlen(s);

    for (int i = 0; i < n; i++) {
        s[n + i] = s[i];
    }
    s[2 * n] = '\0';

    int start = maximum_representation(n);

    printf("Maximum representation starts at: %d\n", start);
    printf("Maximum representation: ");
    for (int i = 0; i < n; i++) {
        printf("%c", s[start + i]);
    }
    printf("\n");

    return 0;
}
```

Python版本：
```python
def maximum_representation(s):
    """求字符串的最大表示"""
    n = len(s)
    s = s + s

    i, j, k = 0, 1, 0

    while i < n and j < n and k < n:
        if s[i + k] == s[j + k]:
            k += 1
            continue

        if s[i + k] < s[j + k]:
            i = i + k + 1
            if i <= j:
                i = j + 1
        else:
            j = j + k + 1
            if j <= i:
                j = i + 1

        k = 0

    start = min(i, j)
    return start, s[start:start + n]

def solve():
    s = input().strip()
    start, result = maximum_representation(s)

    print(f"Maximum representation starts at: {start}")
    print(f"Maximum representation: {result}")

solve()
```

应用四：Booth算法（另一种最小表示法实现）
-------------------------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

char s[MAXN];

// Booth算法求最小表示
int booth(int n) {
    // 将字符串复制一份
    for (int i = 0; i < n; i++) {
        s[n + i] = s[i];
    }
    s[2 * n] = '\0';

    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        char a = s[i + k];
        char b = s[j + k];

        if (a == b) {
            k++;
        } else {
            if (a > b) {
                i = i + k + 1;
            } else {
                j = j + k + 1;
            }

            if (i == j) {
                j++;
            }

            k = 0;
        }
    }

    return min(i, j);
}

int main() {
    scanf("%s", s);
    int n = strlen(s);

    int start = booth(n);

    printf("Minimum representation (Booth): ");
    for (int i = 0; i < n; i++) {
        printf("%c", s[start + i]);
    }
    printf("\n");

    return 0;
}
```

Python版本：
```python
def booth(s):
    """Booth算法求最小表示"""
    n = len(s)
    s = s + s

    i, j, k = 0, 1, 0

    while i < n and j < n and k < n:
        a = s[i + k]
        b = s[j + k]

        if a == b:
            k += 1
        else:
            if a > b:
                i = i + k + 1
            else:
                j = j + k + 1

            if i == j:
                j += 1

            k = 0

    start = min(i, j)
    return s[start:start + n]

def solve():
    s = input().strip()
    result = booth(s)
    print(f"Minimum representation (Booth): {result}")

solve()
```

应用五：字符串的所有循环移位
---------------------------

C++版本：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;

char s[MAXN];

// 生成所有循环移位
vector<string> generate_rotations(int n) {
    vector<string> rotations;

    for (int i = 0; i < n; i++) {
        string rotation;
        for (int j = 0; j < n; j++) {
            rotation += s[(i + j) % n];
        }
        rotations.push_back(rotation);
    }

    return rotations;
}

// 最小表示法
int minimum_representation(int n) {
    int i = 0, j = 1, k = 0;

    while (i < n && j < n && k < n) {
        if (s[i + k] == s[j + k]) {
            k++;
            continue;
        }

        if (s[i + k] > s[j + k]) {
            i = i + k + 1;
            if (i <= j) {
                i = j + 1;
            }
        } else {
            j = j + k + 1;
            if (j <= i) {
                j = i + 1;
            }
        }

        k = 0;
    }

    return min(i, j);
}

int main() {
    scanf("%s", s);
    int n = strlen(s);

    // 生成所有循环移位
    vector<string> rotations = generate_rotations(n);

    printf("All rotations:\n");
    for (int i = 0; i < n; i++) {
        printf("%d: %s\n", i, rotations[i].c_str());
    }

    // 求最小表示
    for (int i = 0; i < n; i++) {
        s[n + i] = s[i];
    }
    s[2 * n] = '\0';

    int start = minimum_representation(n);

    printf("\nMinimum representation: %s\n", rotations[start].c_str());

    // 验证
    sort(rotations.begin(), rotations.end());
    printf("Verification (sorted): %s\n", rotations[0].c_str());

    return 0;
}
```

Python版本：
```python
def generate_rotations(s):
    """生成所有循环移位"""
    n = len(s)
    rotations = []

    for i in range(n):
        rotation = s[i:] + s[:i]
        rotations.append(rotation)

    return rotations

def minimum_representation(s):
    """求字符串的最小表示"""
    n = len(s)
    s = s + s

    i, j, k = 0, 1, 0

    while i < n and j < n and k < n:
        if s[i + k] == s[j + k]:
            k += 1
            continue

        if s[i + k] > s[j + k]:
            i = i + k + 1
            if i <= j:
                i = j + 1
        else:
            j = j + k + 1
            if j <= i:
                j = i + 1

        k = 0

    start = min(i, j)
    return start

def solve():
    s = input().strip()
    n = len(s)

    # 生成所有循环移位
    rotations = generate_rotations(s)

    print("All rotations:")
    for i, rot in enumerate(rotations):
        print(f"{i}: {rot}")

    # 求最小表示
    start = minimum_representation(s)

    print(f"\nMinimum representation: {rotations[start]}")

    # 验证
    rotations_sorted = sorted(rotations)
    print(f"Verification (sorted): {rotations_sorted[0]}")

solve()
```

典型例题
--------
1. 最小表示法模板（洛谷P1368）：求字符串的最小表示
2. 循环同构（洛谷P4503）：判断两个字符串是否循环同构
3. 字符串的循环移位（Codeforces 1090B）：处理循环移位问题
4. 最小循环表示（UVA 719）：求字符串的最小循环表示
5. 周期字符串（POJ 1509）：求字符串的最小表示

注意事项
--------
1. 字符串复制：
   - 需要将字符串复制一份接在后面
   - 确保数组大小足够（2n）
   - 注意'\0'的放置

2. 指针移动：
   - i和j从0和1开始，确保不相同
   - 移动后检查i和j是否相等
   - k值在发现不等后重置为0

3. 边界条件：
   - 检查指针是否越界（< n）
   - 确保比较的长度不超过n
   - i + k和j + k都要检查

4. 时间复杂度：
   - 虽然有嵌套循环，但总时间O(n)
   - 每次比较失败会跳过k个位置
   - 指针单调递增，总移动次数不超过2n

5. 最小表示 vs 最大表示：
   - 最小表示：找字典序最小的循环移位
   - 最大表示：找字典序最大的循环移位
   - 只需改变比较符号即可

时间复杂度总结
--------------
- 最小表示法：O(n)
- 最大表示法：O(n)
- 生成所有循环移位：O(n²)
- 判断循环同构：O(n)
- 空间复杂度：O(n)

最小表示法是处理循环字符串问题的有力工具，理解双指针的移动策略是掌握该算法的关键。
